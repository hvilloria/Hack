<!--?xml version="1.0" encoding="UTF-8"?-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>
  <!-- classpage -- >
    <!-- RD version: 0.35.3  -->
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
  <meta name="description" content="  Class : String  -   Ruby 2.2.0 ">
  <meta content="2016-08-21 15:31:43 -0500" http-equiv="change-date">
  <!-- rel_prefix  = ''  ENV['RDOC_FOR_WEBSITE']   = true-->
    
    
    
  <!-- rel_prefix = '.'   asset_rel_prefix = ''  --> 
  <title>Class: String (Ruby 2.2.0) </title>
  <link rel="stylesheet" href="string_doc_files/associated.css" type="text/css">
  <!-- link rel="stylesheet" href=".css/obf.css"  -->
  <link rel="stylesheet" href="string_doc_files/inuit.css">
  <link rel="stylesheet" href="string_doc_files/grid.css">
  <link rel="stylesheet" href="string_doc_files/2011.css" type="text/css">
  <link rel="stylesheet" href="string_doc_files/rdoc.css" type="text/css">


  <script src="string_doc_files/analytics.js" async=""></script><script src="string_doc_files/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="string_doc_files/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="string_doc_files/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="string_doc_files/rubydoc.js" type="text/javascript" charset="utf-8"></script> 


   
<script src="string_doc_files/highlight.js"></script>
<script> 
  hljs.tabReplace = '  ';
  hljs.initHighlightingOnLoad();
  </script> 

  <style type="text/css">

    #vulns-alert #vulns{
      background-color: #c33 ! important;
      width: 100%;
      text-align: center;
   }
   
   #vulns-alert #vulns a {
    color: #F99 ! important;
   }
 </style>

   <link rel="stylesheet" href="string_doc_files/extra.css" type="text/css">
  <script src="string_doc_files/extra.js"></script>


<script data-timestamp="1471956941917" src="string_doc_files/embed.js"></script><script src="string_doc_files/C6AILKT.html" type="text/javascript" id="_carbonads_projs"></script></head>

<body id="top" class="class rdocstar">

<div id="actionbar">
<div class="wrapper">
  <ul class="grids g0">
	<li class="grid-2"><a href="https://ruby-doc.org/" target="_top">Home</a></li>
	<li class="grid-2"><a href="https://ruby-doc.org/core-2.2.0" target="_top">Core 2.2.0</a></li>
	<li class="grid-2"><a href="https://ruby-doc.org/stdlib-2.2.0" target="_top">Std-lib 2.2.0</a></li>

	 <!-- li class='grid-2' ><a href='/zems' target='_top' >Zems</a></li -->
   <li class="grid-2"><a href="https://ruby-doc.org/downloads" target="_top">Downloads</a></li>
	 <li class="grid-5 right" id="rd-action-search"><form id="searchbox_011815814100681837392:wnccv6st5qk" action="http://ruby-doc.com/search.html"><input name="cx" value="011815814100681837392:wnccv6st5qk" type="hidden"><input id="rd-search-input" name="q" size="20" type="text">&nbsp;&nbsp;<input name="sa" value="Search" type="submit"><input name="cof" value="FORID:9" type="hidden"></form></li>
	</ul>
</div>
<span id="vulns-alert"><!-- void  -->
</span>
<!-- VERSION HEADER for 2.2.0 NOT FOUND --></div> <!-- end action bar -->
 <div class="wrapper">
  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="https://ruby-doc.org/core-2.2.0/index.html">Home</a>
          <a href="https://ruby-doc.org/core-2.2.0/index.html#classes">Classes</a>
          <a href="https://ruby-doc.org/core-2.2.0/index.html#methods">Methods</a>
          
          
          <!-- br><a id='alternateFormatLink' class='rotate' href="#" onclick='matchingYardUrl()'>YARD version</a -->
          
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul id="file-metadata">

          
          
          
          <li class="in-file">complex.c</li>      
            
          
          <li class="in-file">pack.c</li>      
            
          
          <li class="in-file">rational.c</li>      
            
          
          <li class="in-file">string.c</li>      
            
          
          <li class="in-file">transcode.c</li>      
            
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link"><a href="https://ruby-doc.org/core-2.2.0/Object.html">Object</a></p>
        
      </div>
      

      

      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-c-try_convert">::try_convert</a></li>
          
          <li><a href="#method-i-25">#%</a></li>
          
          <li><a href="#method-i-2A">#*</a></li>
          
          <li><a href="#method-i-2B">#+</a></li>
          
          <li><a href="#method-i-3C-3C">#&lt;&lt;</a></li>
          
          <li><a href="#method-i-3C-3D-3E">#&lt;=&gt;</a></li>
          
          <li><a href="#method-i-3D-3D">#==</a></li>
          
          <li><a href="#method-i-3D-3D-3D">#===</a></li>
          
          <li><a href="#method-i-3D-7E">#=~</a></li>
          
          <li><a href="#method-i-5B-5D">#[]</a></li>
          
          <li><a href="#method-i-5B-5D-3D">#[]=</a></li>
          
          <li><a href="#method-i-ascii_only-3F">#ascii_only?</a></li>
          
          <li><a href="#method-i-b">#b</a></li>
          
          <li><a href="#method-i-bytes">#bytes</a></li>
          
          <li><a href="#method-i-bytesize">#bytesize</a></li>
          
          <li><a href="#method-i-byteslice">#byteslice</a></li>
          
          <li><a href="#method-i-capitalize">#capitalize</a></li>
          
          <li><a href="#method-i-capitalize-21">#capitalize!</a></li>
          
          <li><a href="#method-i-casecmp">#casecmp</a></li>
          
          <li><a href="#method-i-center">#center</a></li>
          
          <li><a href="#method-i-chars">#chars</a></li>
          
          <li><a href="#method-i-chomp">#chomp</a></li>
          
          <li><a href="#method-i-chomp-21">#chomp!</a></li>
          
          <li><a href="#method-i-chop">#chop</a></li>
          
          <li><a href="#method-i-chop-21">#chop!</a></li>
          
          <li><a href="#method-i-chr">#chr</a></li>
          
          <li><a href="#method-i-clear">#clear</a></li>
          
          <li><a href="#method-i-codepoints">#codepoints</a></li>
          
          <li><a href="#method-i-concat">#concat</a></li>
          
          <li><a href="#method-i-count">#count</a></li>
          
          <li><a href="#method-i-crypt">#crypt</a></li>
          
          <li><a href="#method-i-delete">#delete</a></li>
          
          <li><a href="#method-i-delete-21">#delete!</a></li>
          
          <li><a href="#method-i-downcase">#downcase</a></li>
          
          <li><a href="#method-i-downcase-21">#downcase!</a></li>
          
          <li><a href="#method-i-dump">#dump</a></li>
          
          <li><a href="#method-i-each_byte">#each_byte</a></li>
          
          <li><a href="#method-i-each_char">#each_char</a></li>
          
          <li><a href="#method-i-each_codepoint">#each_codepoint</a></li>
          
          <li><a href="#method-i-each_line">#each_line</a></li>
          
          <li><a href="#method-i-empty-3F">#empty?</a></li>
          
          <li><a href="#method-i-encode">#encode</a></li>
          
          <li><a href="#method-i-encode-21">#encode!</a></li>
          
          <li><a href="#method-i-encoding">#encoding</a></li>
          
          <li><a href="#method-i-end_with-3F">#end_with?</a></li>
          
          <li><a href="#method-i-eql-3F">#eql?</a></li>
          
          <li><a href="#method-i-force_encoding">#force_encoding</a></li>
          
          <li><a href="#method-i-getbyte">#getbyte</a></li>
          
          <li><a href="#method-i-gsub">#gsub</a></li>
          
          <li><a href="#method-i-gsub-21">#gsub!</a></li>
          
          <li><a href="#method-i-hash">#hash</a></li>
          
          <li><a href="#method-i-hex">#hex</a></li>
          
          <li><a href="#method-i-include-3F">#include?</a></li>
          
          <li><a href="#method-i-index">#index</a></li>
          
          <li><a href="#method-i-initialize_copy">#initialize_copy</a></li>
          
          <li><a href="#method-i-insert">#insert</a></li>
          
          <li><a href="#method-i-inspect">#inspect</a></li>
          
          <li><a href="#method-i-intern">#intern</a></li>
          
          <li><a href="#method-i-length">#length</a></li>
          
          <li><a href="#method-i-lines">#lines</a></li>
          
          <li><a href="#method-i-ljust">#ljust</a></li>
          
          <li><a href="#method-i-lstrip">#lstrip</a></li>
          
          <li><a href="#method-i-lstrip-21">#lstrip!</a></li>
          
          <li><a href="#method-i-match">#match</a></li>
          
          <li><a href="#method-i-next">#next</a></li>
          
          <li><a href="#method-i-next-21">#next!</a></li>
          
          <li><a href="#method-i-oct">#oct</a></li>
          
          <li><a href="#method-i-ord">#ord</a></li>
          
          <li><a href="#method-i-partition">#partition</a></li>
          
          <li><a href="#method-i-prepend">#prepend</a></li>
          
          <li><a href="#method-i-replace">#replace</a></li>
          
          <li><a href="#method-i-reverse">#reverse</a></li>
          
          <li><a href="#method-i-reverse-21">#reverse!</a></li>
          
          <li><a href="#method-i-rindex">#rindex</a></li>
          
          <li><a href="#method-i-rjust">#rjust</a></li>
          
          <li><a href="#method-i-rpartition">#rpartition</a></li>
          
          <li><a href="#method-i-rstrip">#rstrip</a></li>
          
          <li><a href="#method-i-rstrip-21">#rstrip!</a></li>
          
          <li><a href="#method-i-scan">#scan</a></li>
          
          <li><a href="#method-i-scrub">#scrub</a></li>
          
          <li><a href="#method-i-scrub-21">#scrub!</a></li>
          
          <li><a href="#method-i-setbyte">#setbyte</a></li>
          
          <li><a href="#method-i-size">#size</a></li>
          
          <li><a href="#method-i-slice">#slice</a></li>
          
          <li><a href="#method-i-slice-21">#slice!</a></li>
          
          <li><a href="#method-i-split">#split</a></li>
          
          <li><a href="#method-i-squeeze">#squeeze</a></li>
          
          <li><a href="#method-i-squeeze-21">#squeeze!</a></li>
          
          <li><a href="#method-i-start_with-3F">#start_with?</a></li>
          
          <li><a href="#method-i-strip">#strip</a></li>
          
          <li><a href="#method-i-strip-21">#strip!</a></li>
          
          <li><a href="#method-i-sub">#sub</a></li>
          
          <li><a href="#method-i-sub-21">#sub!</a></li>
          
          <li><a href="#method-i-succ">#succ</a></li>
          
          <li><a href="#method-i-succ-21">#succ!</a></li>
          
          <li><a href="#method-i-sum">#sum</a></li>
          
          <li><a href="#method-i-swapcase">#swapcase</a></li>
          
          <li><a href="#method-i-swapcase-21">#swapcase!</a></li>
          
          <li><a href="#method-i-to_c">#to_c</a></li>
          
          <li><a href="#method-i-to_f">#to_f</a></li>
          
          <li><a href="#method-i-to_i">#to_i</a></li>
          
          <li><a href="#method-i-to_r">#to_r</a></li>
          
          <li><a href="#method-i-to_s">#to_s</a></li>
          
          <li><a href="#method-i-to_str">#to_str</a></li>
          
          <li><a href="#method-i-to_sym">#to_sym</a></li>
          
          <li><a href="#method-i-tr">#tr</a></li>
          
          <li><a href="#method-i-tr-21">#tr!</a></li>
          
          <li><a href="#method-i-tr_s">#tr_s</a></li>
          
          <li><a href="#method-i-tr_s-21">#tr_s!</a></li>
          
          <li><a href="#method-i-unpack">#unpack</a></li>
          
          <li><a href="#method-i-upcase">#upcase</a></li>
          
          <li><a href="#method-i-upcase-21">#upcase!</a></li>
          
          <li><a href="#method-i-upto">#upto</a></li>
          
          <li><a href="#method-i-valid_encoding-3F">#valid_encoding?</a></li>
          
        </ul>
      </div>
      

      
      <!-- Included Modules -->
      <div id="includes-section" class="section">
        <h3 class="section-header">Included Modules</h3>
        <ul class="link-list">
        
        
          <li><a class="include" href="https://ruby-doc.org/core-2.2.0/Comparable.html">Comparable</a></li>
        
        
        </ul>
      </div>
      
    </div>

    <div id="project-metadata">
      
      
      <div id="fileindex-section" class="section project-section">
        <h3 class="section-header">Files</h3>
        <ul id="files">
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/_lib/racc/rdoc/grammar_en_rdoc.html">grammar.en.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/_test/rdoc/test_ja_rdoc.html">test.ja.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/doc/contributing_rdoc.html">contributing.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/doc/contributors_rdoc.html">contributors.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/doc/dtrace_probes_rdoc.html">dtrace_probes.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/doc/globals_rdoc.html">globals.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/doc/keywords_rdoc.html">keywords.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/doc/maintainers_rdoc.html">maintainers.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/doc/marshal_rdoc.html">marshal.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/doc/regexp_rdoc.html">regexp.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/doc/security_rdoc.html">security.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/doc/standard_library_rdoc.html">standard_library.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/doc/syntax_rdoc.html">syntax.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/doc/syntax/assignment_rdoc.html">assignment.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/doc/syntax/calling_methods_rdoc.html">calling_methods.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/doc/syntax/control_expressions_rdoc.html">control_expressions.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/doc/syntax/exceptions_rdoc.html">exceptions.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/doc/syntax/literals_rdoc.html">literals.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/doc/syntax/methods_rdoc.html">methods.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/doc/syntax/miscellaneous_rdoc.html">miscellaneous.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/doc/syntax/modules_and_classes_rdoc.html">modules_and_classes.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/doc/syntax/precedence_rdoc.html">precedence.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/doc/syntax/refinements_rdoc.html">refinements.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/sample/drb/README_ja_rdoc.html">README.ja.rdoc</a></li>
        
          
          <li class="file"><a href="https://ruby-doc.org/core-2.2.0/sample/drb/README_rdoc.html">README.rdoc</a></li>
        
        </ul>
      </div>
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="string_doc_files/find.png" alt="[+]" title="show/hide quicksearch" height="16" width="16"></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input name="quicksearch" class="quicksearch-field" type="text">
        </fieldset>
        </form>

        <ul class="link-list">
          
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/ArgumentError.html">ArgumentError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Array.html">Array</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/BasicObject.html">BasicObject</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Bignum.html">Bignum</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Binding.html">Binding</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Class.html">Class</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Comparable.html">Comparable</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Complex.html">Complex</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Complex/compatible.html">Complex::compatible</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/ConditionVariable.html">ConditionVariable</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Continuation.html">Continuation</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Data.html">Data</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Dir.html">Dir</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/ENV.html">ENV</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/EOFError.html">EOFError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Encoding.html">Encoding</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Encoding/CompatibilityError.html">Encoding::CompatibilityError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Encoding/Converter.html">Encoding::Converter</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Encoding/ConverterNotFoundError.html">Encoding::ConverterNotFoundError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Encoding/InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Encoding/UndefinedConversionError.html">Encoding::UndefinedConversionError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/EncodingError.html">EncodingError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Enumerable.html">Enumerable</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Enumerator.html">Enumerator</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Enumerator/Generator.html">Enumerator::Generator</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Enumerator/Lazy.html">Enumerator::Lazy</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Enumerator/Yielder.html">Enumerator::Yielder</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Errno.html">Errno</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Exception.html">Exception</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/FalseClass.html">FalseClass</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Fiber.html">Fiber</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/FiberError.html">FiberError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/File.html">File</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/File/Constants.html">File::Constants</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/File/Stat.html">File::Stat</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/FileTest.html">FileTest</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Fixnum.html">Fixnum</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Float.html">Float</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/FloatDomainError.html">FloatDomainError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/GC.html">GC</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/GC/Profiler.html">GC::Profiler</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Hash.html">Hash</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/IO.html">IO</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/IO/EAGAINWaitReadable.html">IO::EAGAINWaitReadable</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/IO/EAGAINWaitWritable.html">IO::EAGAINWaitWritable</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/IO/EINPROGRESSWaitReadable.html">IO::EINPROGRESSWaitReadable</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/IO/EINPROGRESSWaitWritable.html">IO::EINPROGRESSWaitWritable</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/IO/EWOULDBLOCKWaitReadable.html">IO::EWOULDBLOCKWaitReadable</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/IO/EWOULDBLOCKWaitWritable.html">IO::EWOULDBLOCKWaitWritable</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/IO/WaitReadable.html">IO::WaitReadable</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/IO/WaitWritable.html">IO::WaitWritable</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/IOError.html">IOError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/IndexError.html">IndexError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Integer.html">Integer</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Interrupt.html">Interrupt</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Kernel.html">Kernel</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/KeyError.html">KeyError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/LoadError.html">LoadError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/LocalJumpError.html">LocalJumpError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Marshal.html">Marshal</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/MatchData.html">MatchData</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Math.html">Math</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Math/DomainError.html">Math::DomainError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Method.html">Method</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Module.html">Module</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Mutex.html">Mutex</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/NameError.html">NameError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/NilClass.html">NilClass</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/NoMemoryError.html">NoMemoryError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/NoMethodError.html">NoMethodError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/NotImplementedError.html">NotImplementedError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Numeric.html">Numeric</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Object.html">Object</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/ObjectSpace.html">ObjectSpace</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/ObjectSpace/WeakMap.html">ObjectSpace::WeakMap</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Proc.html">Proc</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Process.html">Process</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Process/GID.html">Process::GID</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Process/Status.html">Process::Status</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Process/Sys.html">Process::Sys</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Process/UID.html">Process::UID</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Process/Waiter.html">Process::Waiter</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Queue.html">Queue</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Random.html">Random</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Range.html">Range</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/RangeError.html">RangeError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Rational.html">Rational</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Rational/compatible.html">Rational::compatible</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Regexp.html">Regexp</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/RegexpError.html">RegexpError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/RubyVM.html">RubyVM</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/RubyVM/Env.html">RubyVM::Env</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/RubyVM/InstructionSequence.html">RubyVM::InstructionSequence</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/RuntimeError.html">RuntimeError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/ScriptError.html">ScriptError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/SecurityError.html">SecurityError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Signal.html">Signal</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/SignalException.html">SignalException</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/SizedQueue.html">SizedQueue</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/StandardError.html">StandardError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/StopIteration.html">StopIteration</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/String.html">String</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Struct.html">Struct</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Symbol.html">Symbol</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/SyntaxError.html">SyntaxError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/SystemCallError.html">SystemCallError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/SystemExit.html">SystemExit</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/SystemStackError.html">SystemStackError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Thread.html">Thread</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Thread/Backtrace/Location.html">Thread::Backtrace::Location</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/ThreadError.html">ThreadError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/ThreadGroup.html">ThreadGroup</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/Time.html">Time</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/TracePoint.html">TracePoint</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/TrueClass.html">TrueClass</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/TypeError.html">TypeError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/UnboundMethod.html">UnboundMethod</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/UncaughtThrowError.html">UncaughtThrowError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/ZeroDivisionError.html">ZeroDivisionError</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/fatal.html">fatal</a></li>
        
          
          
          <li><a href="https://ruby-doc.org/core-2.2.0/unknown.html">unknown</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
      <div id="debugging-toggle"><img src="string_doc_files/bug.png" alt="toggle debugging" height="16" width="16"></div>
      
    </div>
  </div> <!-- metadata -->
  <div class="adzbox" id="azk83167">
    
   <div id="carbonads-container"><div class="carbonad">
    <script async="" type="text/javascript" src="string_doc_files/carbon.js" id="_carbonads_js">
      </script>
  </div></div>

   
  </div> 
  <div id="documentation">
    <h1 class="class">String</h1>

    <div id="description" class="description">
      
<p>A <code>String</code> object holds and manipulates an arbitrary sequence of
bytes, typically representing characters. <a href="https://ruby-doc.org/core-2.2.0/String.html">String</a>
objects may be created using <code>String::new</code> or as literals.</p>

<p>Because of aliasing issues, users of strings should be aware of the methods
that modify the contents of a <code>String</code> object.  Typically,
methods with names ending in “!” modify their receiver, while those without
a “!” return a new <code>String</code>.  However, there are exceptions,
such as <code>String#[]=</code>.</p>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      

      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">new(str="")   → new_str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new string object containing a copy of <em>str</em>.</p>
            

            
            <div class="method-source-code" id="new-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_init(int argc, VALUE *argv, VALUE str)
{
    VALUE orig;

    if (argc &gt; 0 &amp;&amp; rb_scan_args(argc, argv, "01", &amp;orig) == 1)
        rb_str_replace(str, orig);
    return str;
}
            </pre> 
            </div><!-- new-source -->
            
          </div>

          

          
        </div><!-- new-method -->
      
        <div id="try_convert-method" class="method-detail ">
          <a name="method-c-try_convert"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">try_convert(obj) → string or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Try to convert <em>obj</em> into a <a href="https://ruby-doc.org/core-2.2.0/String.html">String</a>, using
<a href="https://ruby-doc.org/core-2.2.0/String.html#method-i-to_str">#to_str</a> method. Returns converted
string or nil if <em>obj</em> cannot be converted for any reason.</p>

<pre class="ruby"><span class="ruby-constant">String</span>.<span class="ruby-identifier">try_convert</span>(<span class="ruby-string">"str"</span>)     <span class="ruby-comment">#=&gt; "str"</span>
<span class="ruby-constant">String</span>.<span class="ruby-identifier">try_convert</span>(<span class="ruby-regexp">/re/</span>)      <span class="ruby-comment">#=&gt; nil</span>
</pre>
            

            
            <div class="method-source-code" id="try_convert-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_s_try_convert(VALUE dummy, VALUE str)
{
    return rb_check_string_type(str);
}
            </pre> 
            </div><!-- try_convert-source -->
            
          </div>

          

          
        </div><!-- try_convert-method -->
      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="25-method" class="method-detail ">
          <a name="method-i-25"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">str % arg   → new_str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Format—Uses <em>str</em> as a format specification, and returns the result
of applying it to <em>arg</em>. If the format specification contains more
than one substitution, then <em>arg</em> must be an <code>Array</code> or
<code>Hash</code> containing the values to be substituted. See
<code>Kernel::sprintf</code> for details of the format string.</p>

<pre class="ruby"><span class="ruby-string">"%05d"</span> <span class="ruby-operator">%</span> <span class="ruby-value">123</span>                              <span class="ruby-comment">#=&gt; "00123"</span>
<span class="ruby-string">"%-5s: %08x"</span> <span class="ruby-operator">%</span> [ <span class="ruby-string">"ID"</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">object_id</span> ]   <span class="ruby-comment">#=&gt; "ID   : 200e14d6"</span>
<span class="ruby-string">"foo = %{foo}"</span> <span class="ruby-operator">%</span> { :<span class="ruby-identifier">foo</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'bar'</span> }        <span class="ruby-comment">#=&gt; "foo = bar"</span>
</pre>
            

            
            <div class="method-source-code" id="25-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_format_m(VALUE str, VALUE arg)
{
    VALUE tmp = rb_check_array_type(arg);

    if (!NIL_P(tmp)) {
        VALUE rv = rb_str_format(RARRAY_LENINT(tmp), RARRAY_CONST_PTR(tmp), str);
        RB_GC_GUARD(tmp);
        return rv;
    }
    return rb_str_format(1, &amp;arg, str);
}
            </pre> 
            </div><!-- 25-source -->
            
          </div>

          

          
        </div><!-- 25-method -->
      
        <div id="2A-method" class="method-detail ">
          <a name="method-i-2A"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">str * integer   → new_str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Copy — Returns a new <a href="https://ruby-doc.org/core-2.2.0/String.html">String</a> containing
<code>integer</code> copies of the receiver. <code>integer</code> must be
greater than or equal to 0.</p>

<pre class="ruby"><span class="ruby-string">"Ho! "</span> <span class="ruby-operator">*</span> <span class="ruby-value">3</span>   <span class="ruby-comment">#=&gt; "Ho! Ho! Ho! "</span>
<span class="ruby-string">"Ho! "</span> <span class="ruby-operator">*</span> <span class="ruby-value">0</span>   <span class="ruby-comment">#=&gt; ""</span>
</pre>
            

            
            <div class="method-source-code" id="2A-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_str_times(VALUE str, VALUE times)
{
    VALUE str2;
    long n, len;
    char *ptr2;
    int termlen;

    len = NUM2LONG(times);
    if (len &lt; 0) {
        rb_raise(rb_eArgError, "negative argument");
    }
    if (len &amp;&amp; LONG_MAX/len &lt;  RSTRING_LEN(str)) {
        rb_raise(rb_eArgError, "argument too big");
    }

    len *= RSTRING_LEN(str);
    termlen = TERM_LEN(str);
    str2 = rb_str_new_with_class(str, 0, (len + termlen - 1));
    ptr2 = RSTRING_PTR(str2);
    if (len) {
        n = RSTRING_LEN(str);
        memcpy(ptr2, RSTRING_PTR(str), n);
        while (n &lt;= len/2) {
            memcpy(ptr2 + n, ptr2, n);
            n *= 2;
        }
        memcpy(ptr2 + n, ptr2, len-n);
    }
    STR_SET_LEN(str2, len);
    TERM_FILL(&amp;ptr2[len], termlen);
    OBJ_INFECT(str2, str);
    rb_enc_cr_str_copy_for_substr(str2, str);

    return str2;
}
            </pre> 
            </div><!-- 2A-source -->
            
          </div>

          

          
        </div><!-- 2A-method -->
      
        <div id="2B-method" class="method-detail ">
          <a name="method-i-2B"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">str + other_str   → new_str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Concatenation—Returns a new <code>String</code> containing
<em>other_str</em> concatenated to <em>str</em>.</p>

<pre class="ruby"><span class="ruby-string">"Hello from "</span> <span class="ruby-operator">+</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">to_s</span>   <span class="ruby-comment">#=&gt; "Hello from main"</span>
</pre>
            

            
            <div class="method-source-code" id="2B-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_str_plus(VALUE str1, VALUE str2)
{
    VALUE str3;
    rb_encoding *enc;
    char *ptr1, *ptr2, *ptr3;
    long len1, len2;

    StringValue(str2);
    enc = rb_enc_check(str1, str2);
    RSTRING_GETMEM(str1, ptr1, len1);
    RSTRING_GETMEM(str2, ptr2, len2);
    str3 = rb_str_new(0, len1+len2);
    ptr3 = RSTRING_PTR(str3);
    memcpy(ptr3, ptr1, len1);
    memcpy(ptr3+len1, ptr2, len2);
    TERM_FILL(&amp;ptr3[len1+len2], rb_enc_mbminlen(enc));

    if (OBJ_TAINTED(str1) || OBJ_TAINTED(str2))
        OBJ_TAINT(str3);
    ENCODING_CODERANGE_SET(str3, rb_enc_to_index(enc),
                           ENC_CODERANGE_AND(ENC_CODERANGE(str1), ENC_CODERANGE(str2)));
    RB_GC_GUARD(str1);
    RB_GC_GUARD(str2);
    return str3;
}
            </pre> 
            </div><!-- 2B-source -->
            
          </div>

          

          
        </div><!-- 2B-method -->
      
        <div id="3C-3C-method" class="method-detail ">
          <a name="method-i-3C-3C"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">str &lt;&lt; integer       → str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">str &lt;&lt; obj           → str</span>
            
          </div>
          
          
          <div>
  
            
            <p>Append—Concatenates the given object to <em>str</em>. If the object is a
<code>Integer</code>, it is considered as a codepoint, and is converted to
a character before concatenation.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-string">"hello "</span>
<span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">"world"</span>   <span class="ruby-comment">#=&gt; "hello world"</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-value">33</span>)   <span class="ruby-comment">#=&gt; "hello world!"</span>
</pre>
            

            
            <div class="method-source-code" id="3C-3C-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_str_concat(VALUE str1, VALUE str2)
{
    unsigned int code;
    rb_encoding *enc = STR_ENC_GET(str1);

    if (FIXNUM_P(str2) || RB_TYPE_P(str2, T_BIGNUM)) {
        if (rb_num_to_uint(str2, &amp;code) == 0) {
        }
        else if (FIXNUM_P(str2)) {
            rb_raise(rb_eRangeError, "%ld out of char range", FIX2LONG(str2));
        }
        else {
            rb_raise(rb_eRangeError, "bignum out of char range");
        }
    }
    else {
        return rb_str_append(str1, str2);
    }

    if (enc == rb_usascii_encoding()) {
        /* US-ASCII automatically extended to ASCII-8BIT */
        char buf[1];
        buf[0] = (char)code;
        if (code &gt; 0xFF) {
            rb_raise(rb_eRangeError, "%u out of char range", code);
        }
        rb_str_cat(str1, buf, 1);
        if (code &gt; 127) {
            rb_enc_associate(str1, rb_ascii8bit_encoding());
            ENC_CODERANGE_SET(str1, ENC_CODERANGE_VALID);
        }
    }
    else {
        long pos = RSTRING_LEN(str1);
        int cr = ENC_CODERANGE(str1);
        int len;
        char *buf;

        switch (len = rb_enc_codelen(code, enc)) {
          case ONIGERR_INVALID_CODE_POINT_VALUE:
            rb_raise(rb_eRangeError, "invalid codepoint 0x%X in %s", code, rb_enc_name(enc));
            break;
          case ONIGERR_TOO_BIG_WIDE_CHAR_VALUE:
          case 0:
            rb_raise(rb_eRangeError, "%u out of char range", code);
            break;
        }
        buf = ALLOCA_N(char, len + 1);
        rb_enc_mbcput(code, buf, enc);
        if (rb_enc_precise_mbclen(buf, buf + len + 1, enc) != len) {
            rb_raise(rb_eRangeError, "invalid codepoint 0x%X in %s", code, rb_enc_name(enc));
        }
        rb_str_resize(str1, pos+len);
        memcpy(RSTRING_PTR(str1) + pos, buf, len);
        if (cr == ENC_CODERANGE_7BIT &amp;&amp; code &gt; 127)
            cr = ENC_CODERANGE_VALID;
        ENC_CODERANGE_SET(str1, cr);
    }
    return str1;
}
            </pre> 
            </div><!-- 3C-3C-source -->
            
          </div>

          

          
        </div><!-- 3C-3C-method -->
      
        <div id="3C-3D-3E-method" class="method-detail ">
          <a name="method-i-3C-3D-3E"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">string &lt;=&gt; other_string   → -1, 0, +1 or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Comparison—Returns -1, 0, +1 or nil depending on whether
<code>string</code> is less than, equal to, or greater than
<code>other_string</code>.</p>

<p><code>nil</code> is returned if the two values are incomparable.</p>

<p>If the strings are of different lengths, and the strings are equal when
compared up to the shortest length, then the longer string is considered
greater than the shorter one.</p>

<p><code>&lt;=&gt;</code> is the basis for the methods <code>&lt;</code>,
<code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, and
<code>between?</code>, included from module <a href="https://ruby-doc.org/core-2.2.0/Comparable.html">Comparable</a>. The method String#== does not use
Comparable#==.</p>

<pre class="ruby"><span class="ruby-string">"abcdef"</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-string">"abcde"</span>     <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-string">"abcdef"</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-string">"abcdef"</span>    <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-string">"abcdef"</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-string">"abcdefg"</span>   <span class="ruby-comment">#=&gt; -1</span>
<span class="ruby-string">"abcdef"</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-string">"ABCDEF"</span>    <span class="ruby-comment">#=&gt; 1</span>
</pre>
            

            
            <div class="method-source-code" id="3C-3D-3E-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_cmp_m(VALUE str1, VALUE str2)
{
    int result;

    if (!RB_TYPE_P(str2, T_STRING)) {
        VALUE tmp = rb_check_funcall(str2, rb_intern("to_str"), 0, 0);
        if (RB_TYPE_P(tmp, T_STRING)) {
            result = rb_str_cmp(str1, tmp);
        }
        else {
            return rb_invcmp(str1, str2);
        }
    }
    else {
        result = rb_str_cmp(str1, str2);
    }
    return INT2FIX(result);
}
            </pre> 
            </div><!-- 3C-3D-3E-source -->
            
          </div>

          

          
        </div><!-- 3C-3D-3E-method -->
      
        <div id="3D-3D-method" class="method-detail ">
          <a name="method-i-3D-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">str == obj    → true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <h3 id="method-i-3D-3D-label-Equality">Equality<span><a href="#method-i-3D-3D-label-Equality">¶</a> <a href="#top">↑</a></span></h3>

<p>Returns whether <code>str</code> == <code>obj</code>, similar to Object#==.</p>

<p>If <code>obj</code> is not an instance of <a href="https://ruby-doc.org/core-2.2.0/String.html">String</a>
but responds to <code>to_str</code>, then the two strings are compared
using case equality <a href="https://ruby-doc.org/core-2.2.0/Object.html#method-i-3D-3D-3D">Object#===</a>.</p>

<p>Otherwise, returns similarly to <a href="https://ruby-doc.org/core-2.2.0/String.html#method-i-eql-3F">#eql?</a>, comparing length and content.</p>
            

            
            <div class="method-source-code" id="3D-3D-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_str_equal(VALUE str1, VALUE str2)
{
    if (str1 == str2) return Qtrue;
    if (!RB_TYPE_P(str2, T_STRING)) {
        if (!rb_respond_to(str2, rb_intern("to_str"))) {
            return Qfalse;
        }
        return rb_equal(str2, str1);
    }
    return str_eql(str1, str2);
}
            </pre> 
            </div><!-- 3D-3D-source -->
            
          </div>

          

          
        <div id="3D-3D-method" class="associated_wrapper">
  <div class="associated">
    <h3 class="section-header">Supplemental notes</h3>
<p>These two methods, <code>==</code> and <code>===</code>, share the same implementation.</p>

<p>A good explanation for this was provided  by <a href="http://bandes-storch.net/">Jacob Bandes-Storch</a> on <a href="http://stackoverflow.com/questions/7156955/whats-the-difference-between-equal-eql-and">Stack Exchange.</a></p>
  </div>
 </div></div><!-- 3D-3D-method -->
      
        <div id="3D-3D-3D-method" class="method-detail ">
          <a name="method-i-3D-3D-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">str === obj   → true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <h3 id="method-i-3D-3D-3D-label-Equality">Equality<span><a href="#method-i-3D-3D-3D-label-Equality">¶</a> <a href="#top">↑</a></span></h3>

<p>Returns whether <code>str</code> == <code>obj</code>, similar to Object#==.</p>

<p>If <code>obj</code> is not an instance of <a href="https://ruby-doc.org/core-2.2.0/String.html">String</a>
but responds to <code>to_str</code>, then the two strings are compared
using case equality <a href="https://ruby-doc.org/core-2.2.0/Object.html#method-i-3D-3D-3D">Object#===</a>.</p>

<p>Otherwise, returns similarly to <a href="https://ruby-doc.org/core-2.2.0/String.html#method-i-eql-3F">#eql?</a>, comparing length and content.</p>
            

            
            <div class="method-source-code" id="3D-3D-3D-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_str_equal(VALUE str1, VALUE str2)
{
    if (str1 == str2) return Qtrue;
    if (!RB_TYPE_P(str2, T_STRING)) {
        if (!rb_respond_to(str2, rb_intern("to_str"))) {
            return Qfalse;
        }
        return rb_equal(str2, str1);
    }
    return str_eql(str1, str2);
}
            </pre> 
            </div><!-- 3D-3D-3D-source -->
            
          </div>

          

          
        </div><!-- 3D-3D-3D-method -->
      
        <div id="3D-7E-method" class="method-detail ">
          <a name="method-i-3D-7E"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">str =~ obj   → fixnum or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Match—If <em>obj</em> is a <code>Regexp</code>, use it as a pattern to
match against <em>str</em>,and returns the position the match starts, or
<code>nil</code> if there is no match. Otherwise, invokes <em>obj.=~</em>,
passing <em>str</em> as an argument. The default <code>=~</code> in
<code>Object</code> returns <code>nil</code>.</p>

<p>Note: <code>str =~ regexp</code> is not the same as <code>regexp =~
str</code>. Strings captured from named capture groups are assigned to
local variables only in the second case.</p>

<pre class="ruby"><span class="ruby-string">"cat o' 9 tails"</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/\d/</span>   <span class="ruby-comment">#=&gt; 7</span>
<span class="ruby-string">"cat o' 9 tails"</span> <span class="ruby-operator">=~</span> <span class="ruby-value">9</span>      <span class="ruby-comment">#=&gt; nil</span>
</pre>
            

            
            <div class="method-source-code" id="3D-7E-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_match(VALUE x, VALUE y)
{
    if (SPECIAL_CONST_P(y)) goto generic;
    switch (BUILTIN_TYPE(y)) {
      case T_STRING:
        rb_raise(rb_eTypeError, "type mismatch: String given");

      case T_REGEXP:
        return rb_reg_match(y, x);

      generic:
      default:
        return rb_funcall(y, rb_intern("=~"), 1, x);
    }
}
            </pre> 
            </div><!-- 3D-7E-source -->
            
          </div>

          

          
        <div id="3D-7E-method" class="associated_wrapper">
  <div class="associated">
    <h3 class="section-header">Supplemental notes</h3>
<p>In this example ...</p>

<p><code>"cat o' 9 tails" =~ /\d/   #=&gt; 7</code></p>

<p>... note that the regular expression <code>/\d/</code> will match any
 single digit.  What is returned is not the matched digit, but the 
zero-based location of that digit. The "9" is the eighth character in 
the string, so, counting from zero, the match returns the integer 7.</p>
  </div>
 </div></div><!-- 3D-7E-method -->
      
        <div id="5B-5D-method" class="method-detail ">
          <a name="method-i-5B-5D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">str[index]                 → new_str or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">str[start, length]         → new_str or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">str[range]                 → new_str or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">str[regexp]                → new_str or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">str[regexp, capture]       → new_str or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">str[match_str]             → new_str or nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Element Reference — If passed a single <code>index</code>, returns a
substring of one character at that index. If passed a <code>start</code>
index and a <code>length</code>, returns a substring containing
<code>length</code> characters starting at the <code>index</code>. If
passed a <code>range</code>, its beginning and end are interpreted as
offsets delimiting the substring to be returned.</p>

<p>In these three cases, if an index is negative, it is counted from the end
of the string.  For the <code>start</code> and <code>range</code> cases the
starting index is just before a character and an index matching the
string’s size. Additionally, an empty string is returned when the starting
index for a character range is at the end of the string.</p>

<p>Returns <code>nil</code> if the initial index falls outside the string or
the length is negative.</p>

<p>If a <code>Regexp</code> is supplied, the matching portion of the string is
returned.  If a <code>capture</code> follows the regular expression, which
may be a capture group index or name, follows the regular expression that
component of the <a href="https://ruby-doc.org/core-2.2.0/MatchData.html">MatchData</a> is returned
instead.</p>

<p>If a <code>match_str</code> is given, that string is returned if it occurs
in the string.</p>

<p>Returns <code>nil</code> if the regular expression does not match or the
match string cannot be found.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-string">"hello there"</span>

<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>]                   <span class="ruby-comment">#=&gt; "e"</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">2</span>, <span class="ruby-value">3</span>]                <span class="ruby-comment">#=&gt; "llo"</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">2</span><span class="ruby-operator">..</span><span class="ruby-value">3</span>]                <span class="ruby-comment">#=&gt; "ll"</span>

<span class="ruby-identifier">a</span>[<span class="ruby-value">-3</span>, <span class="ruby-value">2</span>]               <span class="ruby-comment">#=&gt; "er"</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">7</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>]               <span class="ruby-comment">#=&gt; "her"</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-4</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>]              <span class="ruby-comment">#=&gt; "her"</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-2</span><span class="ruby-operator">..</span><span class="ruby-value">-4</span>]              <span class="ruby-comment">#=&gt; ""</span>

<span class="ruby-identifier">a</span>[<span class="ruby-value">11</span>, <span class="ruby-value">0</span>]               <span class="ruby-comment">#=&gt; ""</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">11</span>]                  <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">12</span>, <span class="ruby-value">0</span>]               <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">12</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>]              <span class="ruby-comment">#=&gt; nil</span>

<span class="ruby-identifier">a</span>[<span class="ruby-regexp">/[aeiou](.)\1/</span>]      <span class="ruby-comment">#=&gt; "ell"</span>
<span class="ruby-identifier">a</span>[<span class="ruby-regexp">/[aeiou](.)\1/</span>, <span class="ruby-value">0</span>]   <span class="ruby-comment">#=&gt; "ell"</span>
<span class="ruby-identifier">a</span>[<span class="ruby-regexp">/[aeiou](.)\1/</span>, <span class="ruby-value">1</span>]   <span class="ruby-comment">#=&gt; "l"</span>
<span class="ruby-identifier">a</span>[<span class="ruby-regexp">/[aeiou](.)\1/</span>, <span class="ruby-value">2</span>]   <span class="ruby-comment">#=&gt; nil</span>

<span class="ruby-identifier">a</span>[<span class="ruby-regexp">/(?&lt;vowel&gt;[aeiou])(?&lt;non_vowel&gt;[^aeiou])/</span>, <span class="ruby-string">"non_vowel"</span>] <span class="ruby-comment">#=&gt; "l"</span>
<span class="ruby-identifier">a</span>[<span class="ruby-regexp">/(?&lt;vowel&gt;[aeiou])(?&lt;non_vowel&gt;[^aeiou])/</span>, <span class="ruby-string">"vowel"</span>]     <span class="ruby-comment">#=&gt; "e"</span>

<span class="ruby-identifier">a</span>[<span class="ruby-string">"lo"</span>]                <span class="ruby-comment">#=&gt; "lo"</span>
<span class="ruby-identifier">a</span>[<span class="ruby-string">"bye"</span>]               <span class="ruby-comment">#=&gt; nil</span>
</pre>
            

            
            <div class="method-source-code" id="5B-5D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_aref_m(int argc, VALUE *argv, VALUE str)
{
    if (argc == 2) {
        if (RB_TYPE_P(argv[0], T_REGEXP)) {
            return rb_str_subpat(str, argv[0], argv[1]);
        }
        return rb_str_substr(str, NUM2LONG(argv[0]), NUM2LONG(argv[1]));
    }
    rb_check_arity(argc, 1, 2);
    return rb_str_aref(str, argv[0]);
}
            </pre> 
            </div><!-- 5B-5D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-method -->
      
        <div id="5B-5D-3D-method" class="method-detail ">
          <a name="method-i-5B-5D-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">str[fixnum] = new_str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">str[fixnum, fixnum] = new_str</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">str[range] = aString</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">str[regexp] = new_str</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">str[regexp, fixnum] = new_str</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">str[regexp, name] = new_str</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">str[other_str] = new_str</span>
            
          </div>
          
          
          <div>
  
            
            <p>Element Assignment—Replaces some or all of the content of <em>str</em>. The
portion of the string affected is determined using the same criteria as
<code>String#[]</code>. If the replacement string is not the same length as
the text it is replacing, the string will be adjusted accordingly. If the
regular expression or string is used as the index doesn’t match a position
in the string, <code>IndexError</code> is raised. If the regular expression
form is used, the optional second <code>Fixnum</code> allows you to specify
which portion of the match to replace (effectively using the
<code>MatchData</code> indexing rules. The forms that take a
<code>Fixnum</code> will raise an <code>IndexError</code> if the value is
out of range; the <code>Range</code> form will raise a
<code>RangeError</code>, and the <code>Regexp</code> and
<code>String</code> will raise an <code>IndexError</code> on negative
match.</p>
            

            
            <div class="method-source-code" id="5B-5D-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_aset_m(int argc, VALUE *argv, VALUE str)
{
    if (argc == 3) {
        if (RB_TYPE_P(argv[0], T_REGEXP)) {
            rb_str_subpat_set(str, argv[0], argv[1], argv[2]);
        }
        else {
            rb_str_splice(str, NUM2LONG(argv[0]), NUM2LONG(argv[1]), argv[2]);
        }
        return argv[2];
    }
    rb_check_arity(argc, 2, 3);
    return rb_str_aset(str, argv[0], argv[1]);
}
            </pre> 
            </div><!-- 5B-5D-3D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-3D-method -->
      
        <div id="ascii_only-3F-method" class="method-detail ">
          <a name="method-i-ascii_only-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ascii_only?  → true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns true for a string which has only ASCII characters.</p>

<pre class="ruby"><span class="ruby-string">"abc"</span>.<span class="ruby-identifier">force_encoding</span>(<span class="ruby-string">"UTF-8"</span>).<span class="ruby-identifier">ascii_only?</span>          <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-string">"abc\u{6666}"</span>.<span class="ruby-identifier">force_encoding</span>(<span class="ruby-string">"UTF-8"</span>).<span class="ruby-identifier">ascii_only?</span>  <span class="ruby-comment">#=&gt; false</span>
</pre>
            

            
            <div class="method-source-code" id="ascii_only-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_is_ascii_only_p(VALUE str)
{
    int cr = rb_enc_str_coderange(str);

    return cr == ENC_CODERANGE_7BIT ? Qtrue : Qfalse;
}
            </pre> 
            </div><!-- ascii_only-3F-source -->
            
          </div>

          

          
        </div><!-- ascii_only-3F-method -->
      
        <div id="b-method" class="method-detail ">
          <a name="method-i-b"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">b   → str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a copied string whose encoding is ASCII-8BIT.</p>
            

            
            <div class="method-source-code" id="b-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_b(VALUE str)
{
    VALUE str2 = str_alloc(rb_cString);
    str_replace_shared_without_enc(str2, str);
    OBJ_INFECT(str2, str);
    ENC_CODERANGE_CLEAR(str2);
    return str2;
}
            </pre> 
            </div><!-- b-source -->
            
          </div>

          

          
        </div><!-- b-method -->
      
        <div id="bytes-method" class="method-detail ">
          <a name="method-i-bytes"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">bytes    → an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array of bytes in <em>str</em>.  This is a shorthand for
<code>str.each_byte.to_a</code>.</p>

<p>If a block is given, which is a deprecated form, works the same as
<code>each_byte</code>.</p>
            

            
            <div class="method-source-code" id="bytes-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_bytes(VALUE str)
{
    return rb_str_enumerate_bytes(str, 1);
}
            </pre> 
            </div><!-- bytes-source -->
            
          </div>

          

          
        </div><!-- bytes-method -->
      
        <div id="bytesize-method" class="method-detail ">
          <a name="method-i-bytesize"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">bytesize  → integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the length of <code>str</code> in bytes.</p>

<pre>"\x80\u3042".bytesize  #=&gt; 4
"hello".bytesize       #=&gt; 5</pre>
            

            
            <div class="method-source-code" id="bytesize-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_bytesize(VALUE str)
{
    return LONG2NUM(RSTRING_LEN(str));
}
            </pre> 
            </div><!-- bytesize-source -->
            
          </div>

          

          
        </div><!-- bytesize-method -->
      
        <div id="byteslice-method" class="method-detail ">
          <a name="method-i-byteslice"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">byteslice(fixnum)           → new_str or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">byteslice(fixnum, fixnum)   → new_str or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">byteslice(range)            → new_str or nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Byte Reference—If passed a single <code>Fixnum</code>, returns a substring
of one byte at that position. If passed two <code>Fixnum</code> objects,
returns a substring starting at the offset given by the first, and a length
given by the second. If given a <code>Range</code>, a substring containing
bytes at offsets given by the range is returned. In all three cases, if an
offset is negative, it is counted from the end of <em>str</em>. Returns
<code>nil</code> if the initial offset falls outside the string, the length
is negative, or the beginning of the range is greater than the end. The
encoding of the resulted string keeps original encoding.</p>

<pre>"hello".byteslice(1)     #=&gt; "e"
"hello".byteslice(-1)    #=&gt; "o"
"hello".byteslice(1, 2)  #=&gt; "el"
"\x80\u3042".byteslice(1, 3) #=&gt; "\u3042"
"\x03\u3042\xff".byteslice(1..3) #=&gt; "\u3042"</pre>
            

            
            <div class="method-source-code" id="byteslice-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_byteslice(int argc, VALUE *argv, VALUE str)
{
    if (argc == 2) {
        return str_byte_substr(str, NUM2LONG(argv[0]), NUM2LONG(argv[1]));
    }
    rb_check_arity(argc, 1, 2);
    return str_byte_aref(str, argv[0]);
}
            </pre> 
            </div><!-- byteslice-source -->
            
          </div>

          

          
        </div><!-- byteslice-method -->
      
        <div id="capitalize-method" class="method-detail ">
          <a name="method-i-capitalize"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">capitalize   → new_str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a copy of <em>str</em> with the first character converted to
uppercase and the remainder to lowercase. Note: case conversion is
effective only in ASCII region.</p>

<pre class="ruby"><span class="ruby-string">"hello"</span>.<span class="ruby-identifier">capitalize</span>    <span class="ruby-comment">#=&gt; "Hello"</span>
<span class="ruby-string">"HELLO"</span>.<span class="ruby-identifier">capitalize</span>    <span class="ruby-comment">#=&gt; "Hello"</span>
<span class="ruby-string">"123ABC"</span>.<span class="ruby-identifier">capitalize</span>   <span class="ruby-comment">#=&gt; "123abc"</span>
</pre>
            

            
            <div class="method-source-code" id="capitalize-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_capitalize(VALUE str)
{
    str = rb_str_dup(str);
    rb_str_capitalize_bang(str);
    return str;
}
            </pre> 
            </div><!-- capitalize-source -->
            
          </div>

          

          
        </div><!-- capitalize-method -->
      
        <div id="capitalize-21-method" class="method-detail ">
          <a name="method-i-capitalize-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">capitalize!   → str or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Modifies <em>str</em> by converting the first character to uppercase and
the remainder to lowercase. Returns <code>nil</code> if no changes are
made. Note: case conversion is effective only in ASCII region.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-string">"hello"</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">capitalize!</span>   <span class="ruby-comment">#=&gt; "Hello"</span>
<span class="ruby-identifier">a</span>               <span class="ruby-comment">#=&gt; "Hello"</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">capitalize!</span>   <span class="ruby-comment">#=&gt; nil</span>
</pre>
            

            
            <div class="method-source-code" id="capitalize-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_capitalize_bang(VALUE str)
{
    rb_encoding *enc;
    char *s, *send;
    int modify = 0;
    unsigned int c;
    int n;

    str_modify_keep_cr(str);
    enc = STR_ENC_GET(str);
    rb_str_check_dummy_enc(enc);
    if (RSTRING_LEN(str) == 0 || !RSTRING_PTR(str)) return Qnil;
    s = RSTRING_PTR(str); send = RSTRING_END(str);

    c = rb_enc_codepoint_len(s, send, &amp;n, enc);
    if (rb_enc_islower(c, enc)) {
        rb_enc_mbcput(rb_enc_toupper(c, enc), s, enc);
        modify = 1;
    }
    s += n;
    while (s &lt; send) {
        c = rb_enc_codepoint_len(s, send, &amp;n, enc);
        if (rb_enc_isupper(c, enc)) {
            rb_enc_mbcput(rb_enc_tolower(c, enc), s, enc);
            modify = 1;
        }
        s += n;
    }

    if (modify) return str;
    return Qnil;
}
            </pre> 
            </div><!-- capitalize-21-source -->
            
          </div>

          

          
        </div><!-- capitalize-21-method -->
      
        <div id="casecmp-method" class="method-detail ">
          <a name="method-i-casecmp"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">casecmp(other_str)   → -1, 0, +1 or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Case-insensitive version of <code>String#&lt;=&gt;</code>.</p>

<pre class="ruby"><span class="ruby-string">"abcdef"</span>.<span class="ruby-identifier">casecmp</span>(<span class="ruby-string">"abcde"</span>)     <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-string">"aBcDeF"</span>.<span class="ruby-identifier">casecmp</span>(<span class="ruby-string">"abcdef"</span>)    <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-string">"abcdef"</span>.<span class="ruby-identifier">casecmp</span>(<span class="ruby-string">"abcdefg"</span>)   <span class="ruby-comment">#=&gt; -1</span>
<span class="ruby-string">"abcdef"</span>.<span class="ruby-identifier">casecmp</span>(<span class="ruby-string">"ABCDEF"</span>)    <span class="ruby-comment">#=&gt; 0</span>
</pre>
            

            
            <div class="method-source-code" id="casecmp-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_casecmp(VALUE str1, VALUE str2)
{
    long len;
    rb_encoding *enc;
    char *p1, *p1end, *p2, *p2end;

    StringValue(str2);
    enc = rb_enc_compatible(str1, str2);
    if (!enc) {
        return Qnil;
    }

    p1 = RSTRING_PTR(str1); p1end = RSTRING_END(str1);
    p2 = RSTRING_PTR(str2); p2end = RSTRING_END(str2);
    if (single_byte_optimizable(str1) &amp;&amp; single_byte_optimizable(str2)) {
        while (p1 &lt; p1end &amp;&amp; p2 &lt; p2end) {
            if (*p1 != *p2) {
                unsigned int c1 = TOUPPER(*p1 &amp; 0xff);
                unsigned int c2 = TOUPPER(*p2 &amp; 0xff);
                if (c1 != c2)
                    return INT2FIX(c1 &lt; c2 ? -1 : 1);
            }
            p1++;
            p2++;
        }
    }
    else {
        while (p1 &lt; p1end &amp;&amp; p2 &lt; p2end) {
            int l1, c1 = rb_enc_ascget(p1, p1end, &amp;l1, enc);
            int l2, c2 = rb_enc_ascget(p2, p2end, &amp;l2, enc);

            if (0 &lt;= c1 &amp;&amp; 0 &lt;= c2) {
                c1 = TOUPPER(c1);
                c2 = TOUPPER(c2);
                if (c1 != c2)
                    return INT2FIX(c1 &lt; c2 ? -1 : 1);
            }
            else {
                int r;
                l1 = rb_enc_mbclen(p1, p1end, enc);
                l2 = rb_enc_mbclen(p2, p2end, enc);
                len = l1 &lt; l2 ? l1 : l2;
                r = memcmp(p1, p2, len);
                if (r != 0)
                    return INT2FIX(r &lt; 0 ? -1 : 1);
                if (l1 != l2)
                    return INT2FIX(l1 &lt; l2 ? -1 : 1);
            }
            p1 += l1;
            p2 += l2;
        }
    }
    if (RSTRING_LEN(str1) == RSTRING_LEN(str2)) return INT2FIX(0);
    if (RSTRING_LEN(str1) &gt; RSTRING_LEN(str2)) return INT2FIX(1);
    return INT2FIX(-1);
}
            </pre> 
            </div><!-- casecmp-source -->
            
          </div>

          

          
        </div><!-- casecmp-method -->
      
        <div id="center-method" class="method-detail ">
          <a name="method-i-center"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">center(width, padstr=' ')   → new_str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Centers <code>str</code> in <code>width</code>.  If <code>width</code> is
greater than the length of <code>str</code>, returns a new <a href="https://ruby-doc.org/core-2.2.0/String.html">String</a> of length <code>width</code> with
<code>str</code> centered and padded with <code>padstr</code>; otherwise,
returns <code>str</code>.</p>

<pre class="ruby"><span class="ruby-string">"hello"</span>.<span class="ruby-identifier">center</span>(<span class="ruby-value">4</span>)         <span class="ruby-comment">#=&gt; "hello"</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">center</span>(<span class="ruby-value">20</span>)        <span class="ruby-comment">#=&gt; "       hello        "</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">center</span>(<span class="ruby-value">20</span>, <span class="ruby-string">'123'</span>) <span class="ruby-comment">#=&gt; "1231231hello12312312"</span>
</pre>
            

            
            <div class="method-source-code" id="center-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_center(int argc, VALUE *argv, VALUE str)
{
    return rb_str_justify(argc, argv, str, 'c');
}
            </pre> 
            </div><!-- center-source -->
            
          </div>

          

          
        </div><!-- center-method -->
      
        <div id="chars-method" class="method-detail ">
          <a name="method-i-chars"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">chars    → an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array of characters in <em>str</em>.  This is a shorthand for
<code>str.each_char.to_a</code>.</p>

<p>If a block is given, which is a deprecated form, works the same as
<code>each_char</code>.</p>
            

            
            <div class="method-source-code" id="chars-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_chars(VALUE str)
{
    return rb_str_enumerate_chars(str, 1);
}
            </pre> 
            </div><!-- chars-source -->
            
          </div>

          

          
        </div><!-- chars-method -->
      
        <div id="chomp-method" class="method-detail ">
          <a name="method-i-chomp"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">chomp(separator=$/)   → new_str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new <code>String</code> with the given record separator removed
from the end of <em>str</em> (if present). If <code>$/</code> has not been
changed from the default Ruby record separator, then <code>chomp</code>
also removes carriage return characters (that is it will remove
<code>\n</code>, <code>\r</code>, and <code>\r\n</code>). If
<code>$/</code> is an empty string, it will remove all trailing newlines
from the string.</p>

<pre class="ruby"><span class="ruby-string">"hello"</span>.<span class="ruby-identifier">chomp</span>                <span class="ruby-comment">#=&gt; "hello"</span>
<span class="ruby-string">"hello\n"</span>.<span class="ruby-identifier">chomp</span>              <span class="ruby-comment">#=&gt; "hello"</span>
<span class="ruby-string">"hello\r\n"</span>.<span class="ruby-identifier">chomp</span>            <span class="ruby-comment">#=&gt; "hello"</span>
<span class="ruby-string">"hello\n\r"</span>.<span class="ruby-identifier">chomp</span>            <span class="ruby-comment">#=&gt; "hello\n"</span>
<span class="ruby-string">"hello\r"</span>.<span class="ruby-identifier">chomp</span>              <span class="ruby-comment">#=&gt; "hello"</span>
<span class="ruby-string">"hello \n there"</span>.<span class="ruby-identifier">chomp</span>       <span class="ruby-comment">#=&gt; "hello \n there"</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">chomp</span>(<span class="ruby-string">"llo"</span>)         <span class="ruby-comment">#=&gt; "he"</span>
<span class="ruby-string">"hello\r\n\r\n"</span>.<span class="ruby-identifier">chomp</span>(<span class="ruby-string">''</span>)    <span class="ruby-comment">#=&gt; "hello"</span>
<span class="ruby-string">"hello\r\n\r\r\n"</span>.<span class="ruby-identifier">chomp</span>(<span class="ruby-string">''</span>)  <span class="ruby-comment">#=&gt; "hello\r\n\r"</span>
</pre>
            

            
            <div class="method-source-code" id="chomp-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_chomp(int argc, VALUE *argv, VALUE str)
{
    VALUE rs = chomp_rs(argc, argv);
    if (NIL_P(rs)) return rb_str_dup(str);
    return rb_str_subseq(str, 0, chompped_length(str, rs));
}
            </pre> 
            </div><!-- chomp-source -->
            
          </div>

          

          
        </div><!-- chomp-method -->
      
        <div id="chomp-21-method" class="method-detail ">
          <a name="method-i-chomp-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">chomp!(separator=$/)   → str or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Modifies <em>str</em> in place as described for <code>String#chomp</code>,
returning <em>str</em>, or <code>nil</code> if no modifications were made.</p>
            

            
            <div class="method-source-code" id="chomp-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_chomp_bang(int argc, VALUE *argv, VALUE str)
{
    VALUE rs;
    long olen;
    str_modify_keep_cr(str);
    if ((olen = RSTRING_LEN(str)) &gt; 0 &amp;&amp; !NIL_P(rs = chomp_rs(argc, argv))) {
        long len;
        len = chompped_length(str, rs);
        if (len &lt; olen) {
            STR_SET_LEN(str, len);
            TERM_FILL(&amp;RSTRING_PTR(str)[len], TERM_LEN(str));
            if (ENC_CODERANGE(str) != ENC_CODERANGE_7BIT) {
                ENC_CODERANGE_CLEAR(str);
            }
            return str;
        }
    }
    return Qnil;
}
            </pre> 
            </div><!-- chomp-21-source -->
            
          </div>

          

          
        </div><!-- chomp-21-method -->
      
        <div id="chop-method" class="method-detail ">
          <a name="method-i-chop"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">chop   → new_str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new <code>String</code> with the last character removed.  If the
string ends with <code>\r\n</code>, both characters are removed. Applying
<code>chop</code> to an empty string returns an empty string.
<code>String#chomp</code> is often a safer alternative, as it leaves the
string unchanged if it doesn’t end in a record separator.</p>

<pre class="ruby"><span class="ruby-string">"string\r\n"</span>.<span class="ruby-identifier">chop</span>   <span class="ruby-comment">#=&gt; "string"</span>
<span class="ruby-string">"string\n\r"</span>.<span class="ruby-identifier">chop</span>   <span class="ruby-comment">#=&gt; "string\n"</span>
<span class="ruby-string">"string\n"</span>.<span class="ruby-identifier">chop</span>     <span class="ruby-comment">#=&gt; "string"</span>
<span class="ruby-string">"string"</span>.<span class="ruby-identifier">chop</span>       <span class="ruby-comment">#=&gt; "strin"</span>
<span class="ruby-string">"x"</span>.<span class="ruby-identifier">chop</span>.<span class="ruby-identifier">chop</span>       <span class="ruby-comment">#=&gt; ""</span>
</pre>
            

            
            <div class="method-source-code" id="chop-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_chop(VALUE str)
{
    return rb_str_subseq(str, 0, chopped_length(str));
}
            </pre> 
            </div><!-- chop-source -->
            
          </div>

          

          
        </div><!-- chop-method -->
      
        <div id="chop-21-method" class="method-detail ">
          <a name="method-i-chop-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">chop!   → str or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Processes <em>str</em> as for <code>String#chop</code>, returning
<em>str</em>, or <code>nil</code> if <em>str</em> is the empty string.  See
also <code>String#chomp!</code>.</p>
            

            
            <div class="method-source-code" id="chop-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_chop_bang(VALUE str)
{
    str_modify_keep_cr(str);
    if (RSTRING_LEN(str) &gt; 0) {
        long len;
        len = chopped_length(str);
        STR_SET_LEN(str, len);
        TERM_FILL(&amp;RSTRING_PTR(str)[len], TERM_LEN(str));
        if (ENC_CODERANGE(str) != ENC_CODERANGE_7BIT) {
            ENC_CODERANGE_CLEAR(str);
        }
        return str;
    }
    return Qnil;
}
            </pre> 
            </div><!-- chop-21-source -->
            
          </div>

          

          
        </div><!-- chop-21-method -->
      
        <div id="chr-method" class="method-detail ">
          <a name="method-i-chr"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">chr    →  string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a one-character string at the beginning of the string.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-string">"abcde"</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">chr</span>    <span class="ruby-comment">#=&gt; "a"</span>
</pre>
            

            
            <div class="method-source-code" id="chr-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_chr(VALUE str)
{
    return rb_str_substr(str, 0, 1);
}
            </pre> 
            </div><!-- chr-source -->
            
          </div>

          

          
        </div><!-- chr-method -->
      
        <div id="clear-method" class="method-detail ">
          <a name="method-i-clear"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">clear    →  string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Makes string empty.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-string">"abcde"</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">clear</span>    <span class="ruby-comment">#=&gt; ""</span>
</pre>
            

            
            <div class="method-source-code" id="clear-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_clear(VALUE str)
{
    str_discard(str);
    STR_SET_EMBED(str);
    STR_SET_EMBED_LEN(str, 0);
    RSTRING_PTR(str)[0] = 0;
    if (rb_enc_asciicompat(STR_ENC_GET(str)))
        ENC_CODERANGE_SET(str, ENC_CODERANGE_7BIT);
    else
        ENC_CODERANGE_SET(str, ENC_CODERANGE_VALID);
    return str;
}
            </pre> 
            </div><!-- clear-source -->
            
          </div>

          

          
        </div><!-- clear-method -->
      
        <div id="codepoints-method" class="method-detail ">
          <a name="method-i-codepoints"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">codepoints   → an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array of the <code>Integer</code> ordinals of the characters in
<em>str</em>.  This is a shorthand for
<code>str.each_codepoint.to_a</code>.</p>

<p>If a block is given, which is a deprecated form, works the same as
<code>each_codepoint</code>.</p>
            

            
            <div class="method-source-code" id="codepoints-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_codepoints(VALUE str)
{
    return rb_str_enumerate_codepoints(str, 1);
}
            </pre> 
            </div><!-- codepoints-source -->
            
          </div>

          

          
        </div><!-- codepoints-method -->
      
        <div id="concat-method" class="method-detail ">
          <a name="method-i-concat"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">concat(integer)  → str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">concat(obj)      → str</span>
            
          </div>
          
          
          <div>
  
            
            <p>Append—Concatenates the given object to <em>str</em>. If the object is a
<code>Integer</code>, it is considered as a codepoint, and is converted to
a character before concatenation.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-string">"hello "</span>
<span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">"world"</span>   <span class="ruby-comment">#=&gt; "hello world"</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-value">33</span>)   <span class="ruby-comment">#=&gt; "hello world!"</span>
</pre>
            

            
            <div class="method-source-code" id="concat-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_str_concat(VALUE str1, VALUE str2)
{
    unsigned int code;
    rb_encoding *enc = STR_ENC_GET(str1);

    if (FIXNUM_P(str2) || RB_TYPE_P(str2, T_BIGNUM)) {
        if (rb_num_to_uint(str2, &amp;code) == 0) {
        }
        else if (FIXNUM_P(str2)) {
            rb_raise(rb_eRangeError, "%ld out of char range", FIX2LONG(str2));
        }
        else {
            rb_raise(rb_eRangeError, "bignum out of char range");
        }
    }
    else {
        return rb_str_append(str1, str2);
    }

    if (enc == rb_usascii_encoding()) {
        /* US-ASCII automatically extended to ASCII-8BIT */
        char buf[1];
        buf[0] = (char)code;
        if (code &gt; 0xFF) {
            rb_raise(rb_eRangeError, "%u out of char range", code);
        }
        rb_str_cat(str1, buf, 1);
        if (code &gt; 127) {
            rb_enc_associate(str1, rb_ascii8bit_encoding());
            ENC_CODERANGE_SET(str1, ENC_CODERANGE_VALID);
        }
    }
    else {
        long pos = RSTRING_LEN(str1);
        int cr = ENC_CODERANGE(str1);
        int len;
        char *buf;

        switch (len = rb_enc_codelen(code, enc)) {
          case ONIGERR_INVALID_CODE_POINT_VALUE:
            rb_raise(rb_eRangeError, "invalid codepoint 0x%X in %s", code, rb_enc_name(enc));
            break;
          case ONIGERR_TOO_BIG_WIDE_CHAR_VALUE:
          case 0:
            rb_raise(rb_eRangeError, "%u out of char range", code);
            break;
        }
        buf = ALLOCA_N(char, len + 1);
        rb_enc_mbcput(code, buf, enc);
        if (rb_enc_precise_mbclen(buf, buf + len + 1, enc) != len) {
            rb_raise(rb_eRangeError, "invalid codepoint 0x%X in %s", code, rb_enc_name(enc));
        }
        rb_str_resize(str1, pos+len);
        memcpy(RSTRING_PTR(str1) + pos, buf, len);
        if (cr == ENC_CODERANGE_7BIT &amp;&amp; code &gt; 127)
            cr = ENC_CODERANGE_VALID;
        ENC_CODERANGE_SET(str1, cr);
    }
    return str1;
}
            </pre> 
            </div><!-- concat-source -->
            
          </div>

          

          
        </div><!-- concat-method -->
      
        <div id="count-method" class="method-detail ">
          <a name="method-i-count"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">count([other_str]+)   → fixnum</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Each <code>other_str</code> parameter defines a set of characters to count.
The intersection of these sets defines the characters to count in
<code>str</code>.  Any <code>other_str</code> that starts with a caret
<code>^</code> is negated.  The sequence <code>c1-c2</code> means all
characters between c1 and c2.  The backslash character <code>\</code> can
be used to escape <code>^</code> or <code>-</code> and is otherwise ignored
unless it appears at the end of a sequence or the end of a
<code>other_str</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-string">"hello world"</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">count</span> <span class="ruby-string">"lo"</span>                   <span class="ruby-comment">#=&gt; 5</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">count</span> <span class="ruby-string">"lo"</span>, <span class="ruby-string">"o"</span>              <span class="ruby-comment">#=&gt; 2</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">count</span> <span class="ruby-string">"hello"</span>, <span class="ruby-string">"^l"</span>          <span class="ruby-comment">#=&gt; 4</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">count</span> <span class="ruby-string">"ej-m"</span>                 <span class="ruby-comment">#=&gt; 4</span>

<span class="ruby-string">"hello^world"</span>.<span class="ruby-identifier">count</span> <span class="ruby-string">"\\^aeiou"</span> <span class="ruby-comment">#=&gt; 4</span>
<span class="ruby-string">"hello-world"</span>.<span class="ruby-identifier">count</span> <span class="ruby-string">"a\\-eo"</span>   <span class="ruby-comment">#=&gt; 4</span>

<span class="ruby-identifier">c</span> = <span class="ruby-string">"hello world\\r\\n"</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">count</span> <span class="ruby-string">"\\"</span>                   <span class="ruby-comment">#=&gt; 2</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">count</span> <span class="ruby-string">"\\A"</span>                  <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">count</span> <span class="ruby-string">"X-\\w"</span>                <span class="ruby-comment">#=&gt; 3</span>
</pre>
            

            
            <div class="method-source-code" id="count-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_count(int argc, VALUE *argv, VALUE str)
{
    char table[TR_TABLE_SIZE];
    rb_encoding *enc = 0;
    VALUE del = 0, nodel = 0, tstr;
    char *s, *send;
    int i;
    int ascompat;

    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);

    tstr = argv[0];
    StringValue(tstr);
    enc = rb_enc_check(str, tstr);
    if (argc == 1) {
        const char *ptstr;
        if (RSTRING_LEN(tstr) == 1 &amp;&amp; rb_enc_asciicompat(enc) &amp;&amp;
            (ptstr = RSTRING_PTR(tstr),
             ONIGENC_IS_ALLOWED_REVERSE_MATCH(enc, (const unsigned char *)ptstr, (const unsigned char *)ptstr+1)) &amp;&amp;
            !is_broken_string(str)) {
            int n = 0;
            int clen;
            unsigned char c = rb_enc_codepoint_len(ptstr, ptstr+1, &amp;clen, enc);

            s = RSTRING_PTR(str);
            if (!s || RSTRING_LEN(str) == 0) return INT2FIX(0);
            send = RSTRING_END(str);
            while (s &lt; send) {
                if (*(unsigned char*)s++ == c) n++;
            }
            return INT2NUM(n);
        }
    }

    tr_setup_table(tstr, table, TRUE, &amp;del, &amp;nodel, enc);
    for (i=1; i&lt;argc; i++) {
        tstr = argv[i];
        StringValue(tstr);
        enc = rb_enc_check(str, tstr);
        tr_setup_table(tstr, table, FALSE, &amp;del, &amp;nodel, enc);
    }

    s = RSTRING_PTR(str);
    if (!s || RSTRING_LEN(str) == 0) return INT2FIX(0);
    send = RSTRING_END(str);
    ascompat = rb_enc_asciicompat(enc);
    i = 0;
    while (s &lt; send) {
        unsigned int c;

        if (ascompat &amp;&amp; (c = *(unsigned char*)s) &lt; 0x80) {
            if (table[c]) {
                i++;
            }
            s++;
        }
        else {
            int clen;
            c = rb_enc_codepoint_len(s, send, &amp;clen, enc);
            if (tr_find(c, table, del, nodel)) {
                i++;
            }
            s += clen;
        }
    }

    return INT2NUM(i);
}
            </pre> 
            </div><!-- count-source -->
            
          </div>

          

          
        </div><!-- count-method -->
      
        <div id="crypt-method" class="method-detail ">
          <a name="method-i-crypt"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">crypt(salt_str)   → new_str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Applies a one-way cryptographic hash to <em>str</em> by invoking the
standard library function <code>crypt(3)</code> with the given salt string.
While the format and the result are system and implementation dependent,
using a salt matching the regular expression
<code>\A[a-zA-Z0-9./]{2}</code> should be valid and safe on any platform,
in which only the first two characters are significant.</p>

<p>This method is for use in system specific scripts, so if you want a
cross-platform hash function consider using Digest or OpenSSL instead.</p>
            

            
            <div class="method-source-code" id="crypt-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_crypt(VALUE str, VALUE salt)
{
    extern char *crypt(const char *, const char *);
    VALUE result;
    const char *s, *saltp;
    char *res;
#ifdef BROKEN_CRYPT
    char salt_8bit_clean[3];
#endif

    StringValue(salt);
    mustnot_wchar(str);
    mustnot_wchar(salt);
    if (RSTRING_LEN(salt) &lt; 2) {
      short_salt:
        rb_raise(rb_eArgError, "salt too short (need &gt;=2 bytes)");
    }

    s = RSTRING_PTR(str);
    if (!s) s = "";
    saltp = RSTRING_PTR(salt);
    if (!saltp[0] || !saltp[1]) goto short_salt;
#ifdef BROKEN_CRYPT
    if (!ISASCII((unsigned char)saltp[0]) || !ISASCII((unsigned char)saltp[1])) {
        salt_8bit_clean[0] = saltp[0] &amp; 0x7f;
        salt_8bit_clean[1] = saltp[1] &amp; 0x7f;
        salt_8bit_clean[2] = '\0';
        saltp = salt_8bit_clean;
    }
#endif
    res = crypt(s, saltp);
    if (!res) {
        rb_sys_fail("crypt");
    }
    result = rb_str_new_cstr(res);
    OBJ_INFECT(result, str);
    OBJ_INFECT(result, salt);
    return result;
}
            </pre> 
            </div><!-- crypt-source -->
            
          </div>

          

          
        </div><!-- crypt-method -->
      
        <div id="delete-method" class="method-detail ">
          <a name="method-i-delete"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">delete([other_str]+)   → new_str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a copy of <em>str</em> with all characters in the intersection of
its arguments deleted. Uses the same rules for building the set of
characters as <code>String#count</code>.</p>

<pre class="ruby"><span class="ruby-string">"hello"</span>.<span class="ruby-identifier">delete</span> <span class="ruby-string">"l"</span>,<span class="ruby-string">"lo"</span>        <span class="ruby-comment">#=&gt; "heo"</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">delete</span> <span class="ruby-string">"lo"</span>            <span class="ruby-comment">#=&gt; "he"</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">delete</span> <span class="ruby-string">"aeiou"</span>, <span class="ruby-string">"^e"</span>   <span class="ruby-comment">#=&gt; "hell"</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">delete</span> <span class="ruby-string">"ej-m"</span>          <span class="ruby-comment">#=&gt; "ho"</span>
</pre>
            

            
            <div class="method-source-code" id="delete-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_delete(int argc, VALUE *argv, VALUE str)
{
    str = rb_str_dup(str);
    rb_str_delete_bang(argc, argv, str);
    return str;
}
            </pre> 
            </div><!-- delete-source -->
            
          </div>

          

          
        </div><!-- delete-method -->
      
        <div id="delete-21-method" class="method-detail ">
          <a name="method-i-delete-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">delete!([other_str]+)   → str or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Performs a <code>delete</code> operation in place, returning <em>str</em>,
or <code>nil</code> if <em>str</em> was not modified.</p>
            

            
            <div class="method-source-code" id="delete-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_delete_bang(int argc, VALUE *argv, VALUE str)
{
    char squeez[TR_TABLE_SIZE];
    rb_encoding *enc = 0;
    char *s, *send, *t;
    VALUE del = 0, nodel = 0;
    int modify = 0;
    int i, ascompat, cr;

    if (RSTRING_LEN(str) == 0 || !RSTRING_PTR(str)) return Qnil;
    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    for (i=0; i&lt;argc; i++) {
        VALUE s = argv[i];

        StringValue(s);
        enc = rb_enc_check(str, s);
        tr_setup_table(s, squeez, i==0, &amp;del, &amp;nodel, enc);
    }

    str_modify_keep_cr(str);
    ascompat = rb_enc_asciicompat(enc);
    s = t = RSTRING_PTR(str);
    send = RSTRING_END(str);
    cr = ascompat ? ENC_CODERANGE_7BIT : ENC_CODERANGE_VALID;
    while (s &lt; send) {
        unsigned int c;
        int clen;

        if (ascompat &amp;&amp; (c = *(unsigned char*)s) &lt; 0x80) {
            if (squeez[c]) {
                modify = 1;
            }
            else {
                if (t != s) *t = c;
                t++;
            }
            s++;
        }
        else {
            c = rb_enc_codepoint_len(s, send, &amp;clen, enc);

            if (tr_find(c, squeez, del, nodel)) {
                modify = 1;
            }
            else {
                if (t != s) rb_enc_mbcput(c, t, enc);
                t += clen;
                if (cr == ENC_CODERANGE_7BIT) cr = ENC_CODERANGE_VALID;
            }
            s += clen;
        }
    }
    TERM_FILL(t, TERM_LEN(str));
    STR_SET_LEN(str, t - RSTRING_PTR(str));
    ENC_CODERANGE_SET(str, cr);

    if (modify) return str;
    return Qnil;
}
            </pre> 
            </div><!-- delete-21-source -->
            
          </div>

          

          
        </div><!-- delete-21-method -->
      
        <div id="downcase-method" class="method-detail ">
          <a name="method-i-downcase"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">downcase   → new_str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a copy of <em>str</em> with all uppercase letters replaced with
their lowercase counterparts. The operation is locale insensitive—only
characters “A” to “Z” are affected. Note: case replacement is effective
only in ASCII region.</p>

<pre class="ruby"><span class="ruby-string">"hEllO"</span>.<span class="ruby-identifier">downcase</span>   <span class="ruby-comment">#=&gt; "hello"</span>
</pre>
            

            
            <div class="method-source-code" id="downcase-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_downcase(VALUE str)
{
    str = rb_str_dup(str);
    rb_str_downcase_bang(str);
    return str;
}
            </pre> 
            </div><!-- downcase-source -->
            
          </div>

          

          
        </div><!-- downcase-method -->
      
        <div id="downcase-21-method" class="method-detail ">
          <a name="method-i-downcase-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">downcase!   → str or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Downcases the contents of <em>str</em>, returning <code>nil</code> if no
changes were made. Note: case replacement is effective only in ASCII
region.</p>
            

            
            <div class="method-source-code" id="downcase-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_downcase_bang(VALUE str)
{
    rb_encoding *enc;
    char *s, *send;
    int modify = 0;

    str_modify_keep_cr(str);
    enc = STR_ENC_GET(str);
    rb_str_check_dummy_enc(enc);
    s = RSTRING_PTR(str); send = RSTRING_END(str);
    if (single_byte_optimizable(str)) {
        while (s &lt; send) {
            unsigned int c = *(unsigned char*)s;

            if (rb_enc_isascii(c, enc) &amp;&amp; 'A' &lt;= c &amp;&amp; c &lt;= 'Z') {
                *s = 'a' + (c - 'A');
                modify = 1;
            }
            s++;
        }
    }
    else {
        int ascompat = rb_enc_asciicompat(enc);

        while (s &lt; send) {
            unsigned int c;
            int n;

            if (ascompat &amp;&amp; (c = *(unsigned char*)s) &lt; 0x80) {
                if (rb_enc_isascii(c, enc) &amp;&amp; 'A' &lt;= c &amp;&amp; c &lt;= 'Z') {
                    *s = 'a' + (c - 'A');
                    modify = 1;
                }
                s++;
            }
            else {
                c = rb_enc_codepoint_len(s, send, &amp;n, enc);
                if (rb_enc_isupper(c, enc)) {
                    /* assuming toupper returns codepoint with same size */
                    rb_enc_mbcput(rb_enc_tolower(c, enc), s, enc);
                    modify = 1;
                }
                s += n;
            }
        }
    }

    if (modify) return str;
    return Qnil;
}
            </pre> 
            </div><!-- downcase-21-source -->
            
          </div>

          

          
        </div><!-- downcase-21-method -->
      
        <div id="dump-method" class="method-detail ">
          <a name="method-i-dump"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">dump   → new_str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Produces a version of <code>str</code> with all non-printing characters
replaced by <code>\nnn</code> notation and all special characters escaped.</p>

<pre class="ruby"><span class="ruby-string">"hello \n ''"</span>.<span class="ruby-identifier">dump</span>  <span class="ruby-comment">#=&gt; "\"hello \\n ''\"</span>
</pre>
            

            
            <div class="method-source-code" id="dump-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_str_dump(VALUE str)
{
    rb_encoding *enc = rb_enc_get(str);
    long len;
    const char *p, *pend;
    char *q, *qend;
    VALUE result;
    int u8 = (enc == rb_utf8_encoding());

    len = 2;                    /* "" */
    p = RSTRING_PTR(str); pend = p + RSTRING_LEN(str);
    while (p &lt; pend) {
        unsigned char c = *p++;
        switch (c) {
          case '"':  case '\\':
          case '\n': case '\r':
          case '\t': case '\f':
          case '\013': case '\010': case '\007': case '\033':
            len += 2;
            break;

          case '#':
            len += IS_EVSTR(p, pend) ? 2 : 1;
            break;

          default:
            if (ISPRINT(c)) {
                len++;
            }
            else {
                if (u8 &amp;&amp; c &gt; 0x7F) { /* \u{NN} */
                    int n = rb_enc_precise_mbclen(p-1, pend, enc);
                    if (MBCLEN_CHARFOUND_P(n)) {
                        unsigned int cc = rb_enc_mbc_to_codepoint(p-1, pend, enc);
                        while (cc &gt;&gt;= 4) len++;
                        len += 5;
                        p += MBCLEN_CHARFOUND_LEN(n)-1;
                        break;
                    }
                }
                len += 4;     /* \xNN */
            }
            break;
        }
    }
    if (!rb_enc_asciicompat(enc)) {
        len += 19;             /* ".force_encoding('')" */
        len += strlen(enc-&gt;name);
    }

    result = rb_str_new_with_class(str, 0, len);
    p = RSTRING_PTR(str); pend = p + RSTRING_LEN(str);
    q = RSTRING_PTR(result); qend = q + len + 1;

    *q++ = '"';
    while (p &lt; pend) {
        unsigned char c = *p++;

        if (c == '"' || c == '\\') {
            *q++ = '\\';
            *q++ = c;
        }
        else if (c == '#') {
            if (IS_EVSTR(p, pend)) *q++ = '\\';
            *q++ = '#';
        }
        else if (c == '\n') {
            *q++ = '\\';
            *q++ = 'n';
        }
        else if (c == '\r') {
            *q++ = '\\';
            *q++ = 'r';
        }
        else if (c == '\t') {
            *q++ = '\\';
            *q++ = 't';
        }
        else if (c == '\f') {
            *q++ = '\\';
            *q++ = 'f';
        }
        else if (c == '\013') {
            *q++ = '\\';
            *q++ = 'v';
        }
        else if (c == '\010') {
            *q++ = '\\';
            *q++ = 'b';
        }
        else if (c == '\007') {
            *q++ = '\\';
            *q++ = 'a';
        }
        else if (c == '\033') {
            *q++ = '\\';
            *q++ = 'e';
        }
        else if (ISPRINT(c)) {
            *q++ = c;
        }
        else {
            *q++ = '\\';
            if (u8) {
                int n = rb_enc_precise_mbclen(p-1, pend, enc) - 1;
                if (MBCLEN_CHARFOUND_P(n)) {
                    int cc = rb_enc_mbc_to_codepoint(p-1, pend, enc);
                    p += n;
                    snprintf(q, qend-q, "u{%x}", cc);
                    q += strlen(q);
                    continue;
                }
            }
            snprintf(q, qend-q, "x%02X", c);
            q += 3;
        }
    }
    *q++ = '"';
    *q = '\0';
    if (!rb_enc_asciicompat(enc)) {
        snprintf(q, qend-q, ".force_encoding(\"%s\")", enc-&gt;name);
        enc = rb_ascii8bit_encoding();
    }
    OBJ_INFECT(result, str);
    /* result from dump is ASCII */
    rb_enc_associate(result, enc);
    ENC_CODERANGE_SET(result, ENC_CODERANGE_7BIT);
    return result;
}
            </pre> 
            </div><!-- dump-source -->
            
          </div>

          

          
        </div><!-- dump-method -->
      
        <div id="each_byte-method" class="method-detail ">
          <a name="method-i-each_byte"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_byte {|fixnum| block }    → str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_byte                      → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Passes each byte in <em>str</em> to the given block, or returns an
enumerator if no block is given.</p>

<pre class="ruby"><span class="ruby-string">"hello"</span>.<span class="ruby-identifier">each_byte</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">c</span>, <span class="ruby-string">' '</span> }
</pre>

<p><em>produces:</em></p>

<pre>104 101 108 108 111</pre>
            

            
            <div class="method-source-code" id="each_byte-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_each_byte(VALUE str)
{
    return rb_str_enumerate_bytes(str, 0);
}
            </pre> 
            </div><!-- each_byte-source -->
            
          </div>

          

          
        </div><!-- each_byte-method -->
      
        <div id="each_char-method" class="method-detail ">
          <a name="method-i-each_char"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_char {|cstr| block }    → str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_char                    → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Passes each character in <em>str</em> to the given block, or returns an
enumerator if no block is given.</p>

<pre class="ruby"><span class="ruby-string">"hello"</span>.<span class="ruby-identifier">each_char</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">c</span>, <span class="ruby-string">' '</span> }
</pre>

<p><em>produces:</em></p>

<pre class="ruby"><span class="ruby-identifier">h</span> <span class="ruby-identifier">e</span> <span class="ruby-identifier">l</span> <span class="ruby-identifier">l</span> <span class="ruby-identifier">o</span>
</pre>
            

            
            <div class="method-source-code" id="each_char-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_each_char(VALUE str)
{
    return rb_str_enumerate_chars(str, 0);
}
            </pre> 
            </div><!-- each_char-source -->
            
          </div>

          

          
        </div><!-- each_char-method -->
      
        <div id="each_codepoint-method" class="method-detail ">
          <a name="method-i-each_codepoint"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_codepoint {|integer| block }    → str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_codepoint                       → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Passes the <code>Integer</code> ordinal of each character in <em>str</em>,
also known as a <em>codepoint</em> when applied to Unicode strings to the
given block.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-string">"hello\u0639"</span>.<span class="ruby-identifier">each_codepoint</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">c</span>, <span class="ruby-string">' '</span> }
</pre>

<p><em>produces:</em></p>

<pre>104 101 108 108 111 1593</pre>
            

            
            <div class="method-source-code" id="each_codepoint-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_each_codepoint(VALUE str)
{
    return rb_str_enumerate_codepoints(str, 0);
}
            </pre> 
            </div><!-- each_codepoint-source -->
            
          </div>

          

          
        </div><!-- each_codepoint-method -->
      
        <div id="each_line-method" class="method-detail ">
          <a name="method-i-each_line"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_line(separator=$/) {|substr| block }   → str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_line(separator=$/)                     → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Splits <em>str</em> using the supplied parameter as the record separator
(<code>$/</code> by default), passing each substring in turn to the
supplied block.  If a zero-length record separator is supplied, the string
is split into paragraphs delimited by multiple successive newlines.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">print</span> <span class="ruby-string">"Example one\n"</span>
<span class="ruby-string">"hello\nworld"</span>.<span class="ruby-identifier">each_line</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">s</span>}
<span class="ruby-identifier">print</span> <span class="ruby-string">"Example two\n"</span>
<span class="ruby-string">"hello\nworld"</span>.<span class="ruby-identifier">each_line</span>(<span class="ruby-string">'l'</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">s</span>}
<span class="ruby-identifier">print</span> <span class="ruby-string">"Example three\n"</span>
<span class="ruby-string">"hello\n\n\nworld"</span>.<span class="ruby-identifier">each_line</span>(<span class="ruby-string">''</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">s</span>}
</pre>

<p><em>produces:</em></p>

<pre class="ruby"><span class="ruby-constant">Example</span> <span class="ruby-identifier">one</span>
<span class="ruby-string">"hello\n"</span>
<span class="ruby-string">"world"</span>
<span class="ruby-constant">Example</span> <span class="ruby-identifier">two</span>
<span class="ruby-string">"hel"</span>
<span class="ruby-string">"l"</span>
<span class="ruby-string">"o\nworl"</span>
<span class="ruby-string">"d"</span>
<span class="ruby-constant">Example</span> <span class="ruby-identifier">three</span>
<span class="ruby-string">"hello\n\n\n"</span>
<span class="ruby-string">"world"</span>
</pre>
            

            
            <div class="method-source-code" id="each_line-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_each_line(int argc, VALUE *argv, VALUE str)
{
    return rb_str_enumerate_lines(argc, argv, str, 0);
}
            </pre> 
            </div><!-- each_line-source -->
            
          </div>

          

          
        </div><!-- each_line-method -->
      
        <div id="empty-3F-method" class="method-detail ">
          <a name="method-i-empty-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">empty?   → true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if <em>str</em> has a length of zero.</p>

<pre class="ruby"><span class="ruby-string">"hello"</span>.<span class="ruby-identifier">empty?</span>   <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-string">" "</span>.<span class="ruby-identifier">empty?</span>       <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-string">""</span>.<span class="ruby-identifier">empty?</span>        <span class="ruby-comment">#=&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="empty-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_empty(VALUE str)
{
    if (RSTRING_LEN(str) == 0)
        return Qtrue;
    return Qfalse;
}
            </pre> 
            </div><!-- empty-3F-source -->
            
          </div>

          

          
        </div><!-- empty-3F-method -->
      
        <div id="encode-method" class="method-detail ">
          <a name="method-i-encode"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">encode(encoding [, options] )   → str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">encode(dst_encoding, src_encoding [, options] )   → str</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">encode([options])   → str</span>
            
          </div>
          
          
          <div>
  
            
            <p>The first form returns a copy of <code>str</code> transcoded to encoding
<code>encoding</code>. The second form returns a copy of <code>str</code>
transcoded from src_encoding to dst_encoding. The last form returns a copy
of <code>str</code> transcoded to <code>Encoding.default_internal</code>.</p>

<p>By default, the first and second form raise <a href="https://ruby-doc.org/core-2.2.0/Encoding/UndefinedConversionError.html">Encoding::UndefinedConversionError</a>
for characters that are undefined in the destination encoding, and <a href="https://ruby-doc.org/core-2.2.0/Encoding/InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a>
for invalid byte sequences in the source encoding. The last form by default
does not raise exceptions but uses replacement strings.</p>

<p>The <code>options</code> <a href="https://ruby-doc.org/core-2.2.0/Hash.html">Hash</a> gives details for
conversion and can have the following keys:</p>
<dl class="rdoc-list note-list"><dt>:invalid 
</dt><dd>
<p>If the value is <code>:replace</code>, <a href="https://ruby-doc.org/core-2.2.0/String.html#method-i-encode">encode</a> replaces invalid byte
sequences in <code>str</code> with the replacement character.  The default
is to raise the <a href="https://ruby-doc.org/core-2.2.0/Encoding/InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a>
exception</p>
</dd><dt>:undef 
</dt><dd>
<p>If the value is <code>:replace</code>, <a href="https://ruby-doc.org/core-2.2.0/String.html#method-i-encode">encode</a> replaces characters which are
undefined in the destination encoding with the replacement character. The
default is to raise the <a href="https://ruby-doc.org/core-2.2.0/Encoding/UndefinedConversionError.html">Encoding::UndefinedConversionError</a>.</p>
</dd><dt>:replace 
</dt><dd>
<p>Sets the replacement string to the given value. The default replacement
string is “uFFFD” for Unicode encoding forms, and “?” otherwise.</p>
</dd><dt>:fallback 
</dt><dd>
<p>Sets the replacement string by the given object for undefined character. 
The object should be a <a href="https://ruby-doc.org/core-2.2.0/Hash.html">Hash</a>, a <a href="https://ruby-doc.org/core-2.2.0/Proc.html">Proc</a>, a <a href="https://ruby-doc.org/core-2.2.0/Method.html">Method</a>, or an object
which has [] method. Its key is an undefined character encoded in the
source encoding of current transcoder. Its value can be any encoding until
it can be converted into the destination encoding of the transcoder.</p>
</dd><dt>:xml 
</dt><dd>
<p>The value must be <code>:text</code> or <code>:attr</code>. If the value is
<code>:text</code> <a href="https://ruby-doc.org/core-2.2.0/String.html#method-i-encode">encode</a>
replaces undefined characters with their (upper-case hexadecimal) numeric
character references. ‘&amp;’, ‘&lt;’, and ‘&gt;’ are converted to
“&amp;amp;”, “&amp;lt;”, and “&amp;gt;”, respectively. If the value is
<code>:attr</code>, <a href="https://ruby-doc.org/core-2.2.0/String.html#method-i-encode">encode</a> also
quotes the replacement result (using ‘“’), and replaces ‘”’ with
“&amp;quot;”.</p>
</dd><dt>:cr_newline 
</dt><dd>
<p>Replaces LF (“n”) with CR (“r”) if value is true.</p>
</dd><dt>:crlf_newline 
</dt><dd>
<p>Replaces LF (“n”) with CRLF (“rn”) if value is true.</p>
</dd><dt>:universal_newline 
</dt><dd>
<p>Replaces CRLF (“rn”) and CR (“r”) with LF (“n”) if value is true.</p>
</dd></dl>
            

            
            <div class="method-source-code" id="encode-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
str_encode(int argc, VALUE *argv, VALUE str)
{
    VALUE newstr = str;
    int encidx = str_transcode(argc, argv, &amp;newstr);
    return encoded_dup(newstr, str, encidx);
}
            </pre> 
            </div><!-- encode-source -->
            
          </div>

          

          
        </div><!-- encode-method -->
      
        <div id="encode-21-method" class="method-detail ">
          <a name="method-i-encode-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">encode!(encoding [, options] )   → str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">encode!(dst_encoding, src_encoding [, options] )   → str</span>
            
          </div>
          
          
          <div>
  
            
            <p>The first form transcodes the contents of <em>str</em> from str.encoding to
<code>encoding</code>. The second form transcodes the contents of
<em>str</em> from src_encoding to dst_encoding. The options <a href="https://ruby-doc.org/core-2.2.0/Hash.html">Hash</a> gives details for conversion. See <a href="https://ruby-doc.org/core-2.2.0/String.html#method-i-encode">#encode</a> for details. Returns the
string even if no changes were made.</p>
            

            
            <div class="method-source-code" id="encode-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
str_encode_bang(int argc, VALUE *argv, VALUE str)
{
    VALUE newstr;
    int encidx;

    rb_check_frozen(str);

    newstr = str;
    encidx = str_transcode(argc, argv, &amp;newstr);

    if (encidx &lt; 0) return str;
    if (newstr == str) {
        rb_enc_associate_index(str, encidx);
        return str;
    }
    rb_str_shared_replace(str, newstr);
    return str_encode_associate(str, encidx);
}
            </pre> 
            </div><!-- encode-21-source -->
            
          </div>

          

          
        </div><!-- encode-21-method -->
      
        <div id="encoding-method" class="method-detail ">
          <a name="method-i-encoding"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">encoding   → encoding</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the <a href="https://ruby-doc.org/core-2.2.0/Encoding.html">Encoding</a> object that represents the
encoding of obj.</p>
            

            
            <div class="method-source-code" id="encoding-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_obj_encoding(VALUE obj)
{
    int idx = rb_enc_get_index(obj);
    if (idx &lt; 0) {
	rb_raise(rb_eTypeError, "unknown encoding");
    }
    return rb_enc_from_encoding_index(idx &amp; ENC_INDEX_MASK);
}
            </pre> 
            </div><!-- encoding-source -->
            
          </div>

          

          
        </div><!-- encoding-method -->
      
        <div id="end_with-3F-method" class="method-detail ">
          <a name="method-i-end_with-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">end_with?([suffixes]+)   → true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns true if <code>str</code> ends with one of the <code>suffixes</code>
given.</p>
            

            
            <div class="method-source-code" id="end_with-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_end_with(int argc, VALUE *argv, VALUE str)
{
    int i;
    char *p, *s, *e;
    rb_encoding *enc;

    for (i=0; i&lt;argc; i++) {
        VALUE tmp = argv[i];
        StringValue(tmp);
        enc = rb_enc_check(str, tmp);
        if (RSTRING_LEN(str) &lt; RSTRING_LEN(tmp)) continue;
        p = RSTRING_PTR(str);
        e = p + RSTRING_LEN(str);
        s = e - RSTRING_LEN(tmp);
        if (rb_enc_left_char_head(p, s, e, enc) != s)
            continue;
        if (memcmp(s, RSTRING_PTR(tmp), RSTRING_LEN(tmp)) == 0)
            return Qtrue;
    }
    return Qfalse;
}
            </pre> 
            </div><!-- end_with-3F-source -->
            
          </div>

          

          
        </div><!-- end_with-3F-method -->
      
        <div id="eql-3F-method" class="method-detail ">
          <a name="method-i-eql-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">eql?(other)   → true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Two strings are equal if they have the same length and content.</p>
            

            
            <div class="method-source-code" id="eql-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_eql(VALUE str1, VALUE str2)
{
    if (str1 == str2) return Qtrue;
    if (!RB_TYPE_P(str2, T_STRING)) return Qfalse;
    return str_eql(str1, str2);
}
            </pre> 
            </div><!-- eql-3F-source -->
            
          </div>

          

          
        </div><!-- eql-3F-method -->
      
        <div id="force_encoding-method" class="method-detail ">
          <a name="method-i-force_encoding"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">force_encoding(encoding)   → str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Changes the encoding to <code>encoding</code> and returns self.</p>
            

            
            <div class="method-source-code" id="force_encoding-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_force_encoding(VALUE str, VALUE enc)
{
    str_modifiable(str);
    rb_enc_associate(str, rb_to_encoding(enc));
    ENC_CODERANGE_CLEAR(str);
    return str;
}
            </pre> 
            </div><!-- force_encoding-source -->
            
          </div>

          

          
        </div><!-- force_encoding-method -->
      
        <div id="getbyte-method" class="method-detail ">
          <a name="method-i-getbyte"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">getbyte(index)          → 0 .. 255</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>returns the <em>index</em>th byte as an integer.</p>
            

            
            <div class="method-source-code" id="getbyte-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_getbyte(VALUE str, VALUE index)
{
    long pos = NUM2LONG(index);

    if (pos &lt; 0)
        pos += RSTRING_LEN(str);
    if (pos &lt; 0 ||  RSTRING_LEN(str) &lt;= pos)
        return Qnil;

    return INT2FIX((unsigned char)RSTRING_PTR(str)[pos]);
}
            </pre> 
            </div><!-- getbyte-source -->
            
          </div>

          

          
        </div><!-- getbyte-method -->
      
        <div id="gsub-method" class="method-detail ">
          <a name="method-i-gsub"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">gsub(pattern, replacement)       → new_str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">gsub(pattern, hash)              → new_str</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">gsub(pattern) {|match| block }   → new_str</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">gsub(pattern)                    → enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a copy of <em>str</em> with the <em>all</em> occurrences of
<em>pattern</em> substituted for the second argument. The <em>pattern</em>
is typically a <code>Regexp</code>; if given as a <code>String</code>, any
regular expression metacharacters it contains will be interpreted
literally, e.g. <code>'\\d'</code> will match a backlash followed by ‘d’,
instead of a digit.</p>

<p>If <em>replacement</em> is a <code>String</code> it will be substituted for
the matched text. It may contain back-references to the pattern’s capture
groups of the form <code>\\d</code>, where <em>d</em> is a group number, or
<code>\\k&lt;n&gt;</code>, where <em>n</em> is a group name. If it is a
double-quoted string, both back-references must be preceded by an
additional backslash. However, within <em>replacement</em> the special
match variables, such as <code>$&amp;</code>, will not refer to the current
match.</p>

<p>If the second argument is a <code>Hash</code>, and the matched text is one
of its keys, the corresponding value is the replacement string.</p>

<p>In the block form, the current match string is passed in as a parameter,
and variables such as <code>$1</code>, <code>$2</code>, <code>$`</code>,
<code>$&amp;</code>, and <code>$'</code> will be set appropriately. The
value returned by the block will be substituted for the match on each call.</p>

<p>The result inherits any tainting in the original string or any supplied
replacement string.</p>

<p>When neither a block nor a second argument is supplied, an
<code>Enumerator</code> is returned.</p>

<pre class="ruby"><span class="ruby-string">"hello"</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-regexp">/[aeiou]/</span>, <span class="ruby-string">'*'</span>)                  <span class="ruby-comment">#=&gt; "h*ll*"</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-regexp">/([aeiou])/</span>, <span class="ruby-string">'&lt;\1&gt;'</span>)             <span class="ruby-comment">#=&gt; "h&lt;e&gt;ll&lt;o&gt;"</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-regexp">/./</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">s</span>.<span class="ruby-identifier">ord</span>.<span class="ruby-identifier">to_s</span> <span class="ruby-operator">+</span> <span class="ruby-string">' '</span>}      <span class="ruby-comment">#=&gt; "104 101 108 108 111 "</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-regexp">/(?&lt;foo&gt;[aeiou])/</span>, <span class="ruby-string">'{\k&lt;foo&gt;}'</span>)  <span class="ruby-comment">#=&gt; "h{e}ll{o}"</span>
<span class="ruby-string">'hello'</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-regexp">/[eo]/</span>, <span class="ruby-string">'e'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">3</span>, <span class="ruby-string">'o'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'*'</span>)    <span class="ruby-comment">#=&gt; "h3ll*"</span>
</pre>
            

            
            <div class="method-source-code" id="gsub-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_gsub(int argc, VALUE *argv, VALUE str)
{
    return str_gsub(argc, argv, str, 0);
}
            </pre> 
            </div><!-- gsub-source -->
            
          </div>

          

          
        <div id="gsub-method" class="associated_wrapper">
  <div class="associated">
    <h3 class="section-header">Supplemental notes</h3>
<p>The examples are use regular expressions for the pattern; here are some simple examples using strings:</p>

<p><code>"Super guper bag".gsub "g", "d"                     # =&gt; "Super duper bad"</code></p>

<p><code>"Ruby is 13%".gsub( '%' ) {|c| c.ord.to_s + ' ' }   # =&gt; "Ruby is 1337"</code></p>

<p><code>"Terribly complex".gsub "complex", "simple"         # =&gt; "Terribly simple"</code></p>
  </div>
 </div></div><!-- gsub-method -->
      
        <div id="gsub-21-method" class="method-detail ">
          <a name="method-i-gsub-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">gsub!(pattern, replacement)        → str or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">gsub!(pattern) {|match| block }    → str or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">gsub!(pattern)                     → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Performs the substitutions of <code>String#gsub</code> in place, returning
<em>str</em>, or <code>nil</code> if no substitutions were performed. If no
block and no <em>replacement</em> is given, an enumerator is returned
instead.</p>
            

            
            <div class="method-source-code" id="gsub-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_gsub_bang(int argc, VALUE *argv, VALUE str)
{
    str_modify_keep_cr(str);
    return str_gsub(argc, argv, str, 1);
}
            </pre> 
            </div><!-- gsub-21-source -->
            
          </div>

          

          
        </div><!-- gsub-21-method -->
      
        <div id="hash-method" class="method-detail ">
          <a name="method-i-hash"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">hash   → fixnum</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Return a hash based on the string’s length, content and encoding.</p>

<p>See also <a href="https://ruby-doc.org/core-2.2.0/Object.html#method-i-hash">Object#hash</a>.</p>
            

            
            <div class="method-source-code" id="hash-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_hash_m(VALUE str)
{
    st_index_t hval = rb_str_hash(str);
    return INT2FIX(hval);
}
            </pre> 
            </div><!-- hash-source -->
            
          </div>

          

          
        </div><!-- hash-method -->
      
        <div id="hex-method" class="method-detail ">
          <a name="method-i-hex"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">hex   → integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Treats leading characters from <em>str</em> as a string of hexadecimal
digits (with an optional sign and an optional <code>0x</code>) and returns
the corresponding number. Zero is returned on error.</p>

<pre class="ruby"><span class="ruby-string">"0x0a"</span>.<span class="ruby-identifier">hex</span>     <span class="ruby-comment">#=&gt; 10</span>
<span class="ruby-string">"-1234"</span>.<span class="ruby-identifier">hex</span>    <span class="ruby-comment">#=&gt; -4660</span>
<span class="ruby-string">"0"</span>.<span class="ruby-identifier">hex</span>        <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-string">"wombat"</span>.<span class="ruby-identifier">hex</span>   <span class="ruby-comment">#=&gt; 0</span>
</pre>
            

            
            <div class="method-source-code" id="hex-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_hex(VALUE str)
{
    return rb_str_to_inum(str, 16, FALSE);
}
            </pre> 
            </div><!-- hex-source -->
            
          </div>

          

          
        </div><!-- hex-method -->
      
        <div id="include-3F-method" class="method-detail ">
          <a name="method-i-include-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">include? other_str   → true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if <em>str</em> contains the given string or
character.</p>

<pre class="ruby"><span class="ruby-string">"hello"</span>.<span class="ruby-identifier">include?</span> <span class="ruby-string">"lo"</span>   <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">include?</span> <span class="ruby-string">"ol"</span>   <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">include?</span> <span class="ruby-value">?h</span>     <span class="ruby-comment">#=&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="include-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_include(VALUE str, VALUE arg)
{
    long i;

    StringValue(arg);
    i = rb_str_index(str, arg, 0);

    if (i == -1) return Qfalse;
    return Qtrue;
}
            </pre> 
            </div><!-- include-3F-source -->
            
          </div>

          

          
        </div><!-- include-3F-method -->
      
        <div id="index-method" class="method-detail ">
          <a name="method-i-index"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">index(substring [, offset])   → fixnum or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">index(regexp [, offset])      → fixnum or nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the index of the first occurrence of the given <em>substring</em>
or pattern (<em>regexp</em>) in <em>str</em>. Returns <code>nil</code> if
not found. If the second parameter is present, it specifies the position in
the string to begin the search.</p>

<pre class="ruby"><span class="ruby-string">"hello"</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">'e'</span>)             <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">'lo'</span>)            <span class="ruby-comment">#=&gt; 3</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">'a'</span>)             <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">index</span>(<span class="ruby-value">?e</span>)              <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">index</span>(<span class="ruby-regexp">/[aeiou]/</span>, <span class="ruby-value">-3</span>)   <span class="ruby-comment">#=&gt; 4</span>
</pre>
            

            
            <div class="method-source-code" id="index-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_index_m(int argc, VALUE *argv, VALUE str)
{
    VALUE sub;
    VALUE initpos;
    long pos;

    if (rb_scan_args(argc, argv, "11", &amp;sub, &amp;initpos) == 2) {
        pos = NUM2LONG(initpos);
    }
    else {
        pos = 0;
    }
    if (pos &lt; 0) {
        pos += str_strlen(str, NULL);
        if (pos &lt; 0) {
            if (RB_TYPE_P(sub, T_REGEXP)) {
                rb_backref_set(Qnil);
            }
            return Qnil;
        }
    }

    if (SPECIAL_CONST_P(sub)) goto generic;
    switch (BUILTIN_TYPE(sub)) {
      case T_REGEXP:
        if (pos &gt; str_strlen(str, NULL))
            return Qnil;
        pos = str_offset(RSTRING_PTR(str), RSTRING_END(str), pos,
                         rb_enc_check(str, sub), single_byte_optimizable(str));

        pos = rb_reg_search(sub, str, pos, 0);
        pos = rb_str_sublen(str, pos);
        break;

      generic:
      default: {
        VALUE tmp;

        tmp = rb_check_string_type(sub);
        if (NIL_P(tmp)) {
            rb_raise(rb_eTypeError, "type mismatch: %s given",
                     rb_obj_classname(sub));
        }
        sub = tmp;
      }
        /* fall through */
      case T_STRING:
        pos = rb_str_index(str, sub, pos);
        pos = rb_str_sublen(str, pos);
        break;
    }

    if (pos == -1) return Qnil;
    return LONG2NUM(pos);
}
            </pre> 
            </div><!-- index-source -->
            
          </div>

          

          
        </div><!-- index-method -->
      
        <div id="initialize_copy-method" class="method-detail ">
          <a name="method-i-initialize_copy"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">replace(other_str)   → str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Replaces the contents and taintedness of <em>str</em> with the
corresponding values in <em>other_str</em>.</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">"hello"</span>         <span class="ruby-comment">#=&gt; "hello"</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">replace</span> <span class="ruby-string">"world"</span>   <span class="ruby-comment">#=&gt; "world"</span>
</pre>
            

            
            <div class="method-source-code" id="initialize_copy-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_str_replace(VALUE str, VALUE str2)
{
    str_modifiable(str);
    if (str == str2) return str;

    StringValue(str2);
    str_discard(str);
    return str_replace(str, str2);
}
            </pre> 
            </div><!-- initialize_copy-source -->
            
          </div>

          

          
        </div><!-- initialize_copy-method -->
      
        <div id="insert-method" class="method-detail ">
          <a name="method-i-insert"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">insert(index, other_str)   → str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Inserts <em>other_str</em> before the character at the given
<em>index</em>, modifying <em>str</em>. Negative indices count from the end
of the string, and insert <em>after</em> the given character. The intent is
insert <em>aString</em> so that it starts at the given <em>index</em>.</p>

<pre class="ruby"><span class="ruby-string">"abcd"</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">0</span>, <span class="ruby-string">'X'</span>)    <span class="ruby-comment">#=&gt; "Xabcd"</span>
<span class="ruby-string">"abcd"</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">3</span>, <span class="ruby-string">'X'</span>)    <span class="ruby-comment">#=&gt; "abcXd"</span>
<span class="ruby-string">"abcd"</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">4</span>, <span class="ruby-string">'X'</span>)    <span class="ruby-comment">#=&gt; "abcdX"</span>
<span class="ruby-string">"abcd"</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">-3</span>, <span class="ruby-string">'X'</span>)   <span class="ruby-comment">#=&gt; "abXcd"</span>
<span class="ruby-string">"abcd"</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">-1</span>, <span class="ruby-string">'X'</span>)   <span class="ruby-comment">#=&gt; "abcdX"</span>
</pre>
            

            
            <div class="method-source-code" id="insert-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_insert(VALUE str, VALUE idx, VALUE str2)
{
    long pos = NUM2LONG(idx);

    if (pos == -1) {
        return rb_str_append(str, str2);
    }
    else if (pos &lt; 0) {
        pos++;
    }
    rb_str_splice(str, pos, 0, str2);
    return str;
}
            </pre> 
            </div><!-- insert-source -->
            
          </div>

          

          
        </div><!-- insert-method -->
      
        <div id="inspect-method" class="method-detail ">
          <a name="method-i-inspect"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">inspect   → string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a printable version of <em>str</em>, surrounded by quote marks,
with special characters escaped.</p>

<pre class="ruby"><span class="ruby-identifier">str</span> = <span class="ruby-string">"hello"</span>
<span class="ruby-identifier">str</span>[<span class="ruby-value">3</span>] = <span class="ruby-string">"\b"</span>
<span class="ruby-identifier">str</span>.<span class="ruby-identifier">inspect</span>       <span class="ruby-comment">#=&gt; "\"hel\\bo\""</span>
</pre>
            

            
            <div class="method-source-code" id="inspect-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_str_inspect(VALUE str)
{
    int encidx = ENCODING_GET(str);
    rb_encoding *enc = rb_enc_from_index(encidx), *actenc;
    const char *p, *pend, *prev;
    char buf[CHAR_ESC_LEN + 1];
    VALUE result = rb_str_buf_new(0);
    rb_encoding *resenc = rb_default_internal_encoding();
    int unicode_p = rb_enc_unicode_p(enc);
    int asciicompat = rb_enc_asciicompat(enc);

    if (resenc == NULL) resenc = rb_default_external_encoding();
    if (!rb_enc_asciicompat(resenc)) resenc = rb_usascii_encoding();
    rb_enc_associate(result, resenc);
    str_buf_cat2(result, "\"");

    p = RSTRING_PTR(str); pend = RSTRING_END(str);
    prev = p;
    actenc = get_actual_encoding(encidx, str);
    if (actenc != enc) {
        enc = actenc;
        if (unicode_p) unicode_p = rb_enc_unicode_p(enc);
    }
    while (p &lt; pend) {
        unsigned int c, cc;
        int n;

        n = rb_enc_precise_mbclen(p, pend, enc);
        if (!MBCLEN_CHARFOUND_P(n)) {
            if (p &gt; prev) str_buf_cat(result, prev, p - prev);
            n = rb_enc_mbminlen(enc);
            if (pend &lt; p + n)
                n = (int)(pend - p);
            while (n--) {
                snprintf(buf, CHAR_ESC_LEN, "\\x%02X", *p &amp; 0377);
                str_buf_cat(result, buf, strlen(buf));
                prev = ++p;
            }
            continue;
        }
        n = MBCLEN_CHARFOUND_LEN(n);
        c = rb_enc_mbc_to_codepoint(p, pend, enc);
        p += n;
        if ((asciicompat || unicode_p) &amp;&amp;
          (c == '"'|| c == '\\' ||
            (c == '#' &amp;&amp;
             p &lt; pend &amp;&amp;
             MBCLEN_CHARFOUND_P(rb_enc_precise_mbclen(p,pend,enc)) &amp;&amp;
             (cc = rb_enc_codepoint(p,pend,enc),
              (cc == '$' || cc == '@' || cc == '{'))))) {
            if (p - n &gt; prev) str_buf_cat(result, prev, p - n - prev);
            str_buf_cat2(result, "\\");
            if (asciicompat || enc == resenc) {
                prev = p - n;
                continue;
            }
        }
        switch (c) {
          case '\n': cc = 'n'; break;
          case '\r': cc = 'r'; break;
          case '\t': cc = 't'; break;
          case '\f': cc = 'f'; break;
          case '\013': cc = 'v'; break;
          case '\010': cc = 'b'; break;
          case '\007': cc = 'a'; break;
          case 033: cc = 'e'; break;
          default: cc = 0; break;
        }
        if (cc) {
            if (p - n &gt; prev) str_buf_cat(result, prev, p - n - prev);
            buf[0] = '\\';
            buf[1] = (char)cc;
            str_buf_cat(result, buf, 2);
            prev = p;
            continue;
        }
        if ((enc == resenc &amp;&amp; rb_enc_isprint(c, enc)) ||
            (asciicompat &amp;&amp; rb_enc_isascii(c, enc) &amp;&amp; ISPRINT(c))) {
            continue;
        }
        else {
            if (p - n &gt; prev) str_buf_cat(result, prev, p - n - prev);
            rb_str_buf_cat_escaped_char(result, c, unicode_p);
            prev = p;
            continue;
        }
    }
    if (p &gt; prev) str_buf_cat(result, prev, p - prev);
    str_buf_cat2(result, "\"");

    OBJ_INFECT(result, str);
    return result;
}
            </pre> 
            </div><!-- inspect-source -->
            
          </div>

          

          
        </div><!-- inspect-method -->
      
        <div id="intern-method" class="method-detail ">
          <a name="method-i-intern"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">intern   → symbol</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the <code>Symbol</code> corresponding to <em>str</em>, creating the
symbol if it did not previously exist. See <code>Symbol#id2name</code>.</p>

<pre class="ruby"><span class="ruby-string">"Koala"</span>.<span class="ruby-identifier">intern</span>         <span class="ruby-comment">#=&gt; :Koala</span>
<span class="ruby-identifier">s</span> = <span class="ruby-string">'cat'</span>.<span class="ruby-identifier">to_sym</span>       <span class="ruby-comment">#=&gt; :cat</span>
<span class="ruby-identifier">s</span> <span class="ruby-operator">==</span> :<span class="ruby-identifier">cat</span>              <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">s</span> = <span class="ruby-string">'@cat'</span>.<span class="ruby-identifier">to_sym</span>      <span class="ruby-comment">#=&gt; :@cat</span>
<span class="ruby-identifier">s</span> <span class="ruby-operator">==</span> :<span class="ruby-ivar">@cat</span>             <span class="ruby-comment">#=&gt; true</span>
</pre>

<p>This can also be used to create symbols that cannot be represented using
the <code>:xxx</code> notation.</p>

<pre class="ruby"><span class="ruby-string">'cat and dog'</span>.<span class="ruby-identifier">to_sym</span>   <span class="ruby-comment">#=&gt; :"cat and dog"</span>
</pre>
            

            
            <div class="method-source-code" id="intern-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_str_intern(VALUE str)
{
#if USE_SYMBOL_GC
    rb_encoding *enc, *ascii;
    int type;
#else
    ID id;
#endif
    VALUE sym = lookup_str_sym(str);

    if (sym) {
	return sym;
    }

#if USE_SYMBOL_GC
    enc = rb_enc_get(str);
    ascii = rb_usascii_encoding();
    if (enc != ascii) {
	if (sym_check_asciionly(str)) {
	    str = rb_str_dup(str);
	    rb_enc_associate(str, ascii);
	    OBJ_FREEZE(str);
	    enc = ascii;
	}
    }
    str = rb_fstring(str);
    type = rb_str_symname_type(str, IDSET_ATTRSET_FOR_INTERN);
    if (type &lt; 0) type = ID_JUNK;
    return dsymbol_alloc(rb_cSymbol, str, enc, type);
#else
    id = intern_str(str, 0);
    return ID2SYM(id);
#endif
}
            </pre> 
            </div><!-- intern-source -->
            
          </div>

          

          
        </div><!-- intern-method -->
      
        <div id="length-method" class="method-detail ">
          <a name="method-i-length"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">length   → integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the character length of <em>str</em>.</p>
            

            
            <div class="method-source-code" id="length-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_str_length(VALUE str)
{
    return LONG2NUM(str_strlen(str, NULL));
}
            </pre> 
            </div><!-- length-source -->
            
          </div>

          

          
        </div><!-- length-method -->
      
        <div id="lines-method" class="method-detail ">
          <a name="method-i-lines"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">lines(separator=$/)  → an_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array of lines in <em>str</em> split using the supplied record
separator (<code>$/</code> by default).  This is a shorthand for
<code>str.each_line(separator).to_a</code>.</p>

<p>If a block is given, which is a deprecated form, works the same as
<code>each_line</code>.</p>
            

            
            <div class="method-source-code" id="lines-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_lines(int argc, VALUE *argv, VALUE str)
{
    return rb_str_enumerate_lines(argc, argv, str, 1);
}
            </pre> 
            </div><!-- lines-source -->
            
          </div>

          

          
        </div><!-- lines-method -->
      
        <div id="ljust-method" class="method-detail ">
          <a name="method-i-ljust"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ljust(integer, padstr=' ')   → new_str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>If <em>integer</em> is greater than the length of <em>str</em>, returns a
new <code>String</code> of length <em>integer</em> with <em>str</em> left
justified and padded with <em>padstr</em>; otherwise, returns <em>str</em>.</p>

<pre class="ruby"><span class="ruby-string">"hello"</span>.<span class="ruby-identifier">ljust</span>(<span class="ruby-value">4</span>)            <span class="ruby-comment">#=&gt; "hello"</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">ljust</span>(<span class="ruby-value">20</span>)           <span class="ruby-comment">#=&gt; "hello               "</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">ljust</span>(<span class="ruby-value">20</span>, <span class="ruby-string">'1234'</span>)   <span class="ruby-comment">#=&gt; "hello123412341234123"</span>
</pre>
            

            
            <div class="method-source-code" id="ljust-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_ljust(int argc, VALUE *argv, VALUE str)
{
    return rb_str_justify(argc, argv, str, 'l');
}
            </pre> 
            </div><!-- ljust-source -->
            
          </div>

          

          
        </div><!-- ljust-method -->
      
        <div id="lstrip-method" class="method-detail ">
          <a name="method-i-lstrip"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">lstrip   → new_str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a copy of <em>str</em> with leading whitespace removed. See also
<code>String#rstrip</code> and <code>String#strip</code>.</p>

<pre class="ruby"><span class="ruby-string">"  hello  "</span>.<span class="ruby-identifier">lstrip</span>   <span class="ruby-comment">#=&gt; "hello  "</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">lstrip</span>       <span class="ruby-comment">#=&gt; "hello"</span>
</pre>
            

            
            <div class="method-source-code" id="lstrip-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_lstrip(VALUE str)
{
    char *start;
    long len, loffset;
    RSTRING_GETMEM(str, start, len);
    loffset = lstrip_offset(str, start, start+len, STR_ENC_GET(str));
    if (loffset &lt;= 0) return rb_str_dup(str);
    return rb_str_subseq(str, loffset, len - loffset);
}
            </pre> 
            </div><!-- lstrip-source -->
            
          </div>

          

          
        </div><!-- lstrip-method -->
      
        <div id="lstrip-21-method" class="method-detail ">
          <a name="method-i-lstrip-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">lstrip!   → self or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Removes leading whitespace from <em>str</em>, returning <code>nil</code> if
no change was made. See also <code>String#rstrip!</code> and
<code>String#strip!</code>.</p>

<pre class="ruby"><span class="ruby-string">"  hello  "</span>.<span class="ruby-identifier">lstrip</span>   <span class="ruby-comment">#=&gt; "hello  "</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">lstrip!</span>      <span class="ruby-comment">#=&gt; nil</span>
</pre>
            

            
            <div class="method-source-code" id="lstrip-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_lstrip_bang(VALUE str)
{
    rb_encoding *enc;
    char *start, *s;
    long olen, loffset;

    str_modify_keep_cr(str);
    enc = STR_ENC_GET(str);
    RSTRING_GETMEM(str, start, olen);
    loffset = lstrip_offset(str, start, start+olen, enc);
    if (loffset &gt; 0) {
        long len = olen-loffset;
        s = start + loffset;
        memmove(start, s, len);
        STR_SET_LEN(str, len);
#if !SHARABLE_MIDDLE_SUBSTRING
        TERM_FILL(start+len, rb_enc_mbminlen(enc));
#endif
        return str;
    }
    return Qnil;
}
            </pre> 
            </div><!-- lstrip-21-source -->
            
          </div>

          

          
        </div><!-- lstrip-21-method -->
      
        <div id="match-method" class="method-detail ">
          <a name="method-i-match"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">match(pattern)        → matchdata or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">match(pattern, pos)   → matchdata or nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Converts <em>pattern</em> to a <code>Regexp</code> (if it isn’t already
one), then invokes its <code>match</code> method on <em>str</em>.  If the
second parameter is present, it specifies the position in the string to
begin the search.</p>

<pre class="ruby"><span class="ruby-string">'hello'</span>.<span class="ruby-identifier">match</span>(<span class="ruby-string">'(.)\1'</span>)      <span class="ruby-comment">#=&gt; #&lt;MatchData "ll" 1:"l"&gt;</span>
<span class="ruby-string">'hello'</span>.<span class="ruby-identifier">match</span>(<span class="ruby-string">'(.)\1'</span>)[<span class="ruby-value">0</span>]   <span class="ruby-comment">#=&gt; "ll"</span>
<span class="ruby-string">'hello'</span>.<span class="ruby-identifier">match</span>(<span class="ruby-regexp">/(.)\1/</span>)[<span class="ruby-value">0</span>]   <span class="ruby-comment">#=&gt; "ll"</span>
<span class="ruby-string">'hello'</span>.<span class="ruby-identifier">match</span>(<span class="ruby-string">'xx'</span>)         <span class="ruby-comment">#=&gt; nil</span>
</pre>

<p>If a block is given, invoke the block with <a href="https://ruby-doc.org/core-2.2.0/MatchData.html">MatchData</a> if match succeed, so that you can write</p>

<pre>str.match(pat) {|m| ...}</pre>

<p>instead of</p>

<pre>if m = str.match(pat)
  ...
end</pre>

<p>The return value is a value from block execution in this case.</p>
            

            
            <div class="method-source-code" id="match-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_match_m(int argc, VALUE *argv, VALUE str)
{
    VALUE re, result;
    if (argc &lt; 1)
        rb_check_arity(argc, 1, 2);
    re = argv[0];
    argv[0] = str;
    result = rb_funcall2(get_pat(re), rb_intern("match"), argc, argv);
    if (!NIL_P(result) &amp;&amp; rb_block_given_p()) {
        return rb_yield(result);
    }
    return result;
}
            </pre> 
            </div><!-- match-source -->
            
          </div>

          

          
        </div><!-- match-method -->
      
        <div id="next-method" class="method-detail ">
          <a name="method-i-next"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">next   → new_str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the successor to <em>str</em>. The successor is calculated by
incrementing characters starting from the rightmost alphanumeric (or the
rightmost character if there are no alphanumerics) in the string.
Incrementing a digit always results in another digit, and incrementing a
letter results in another letter of the same case. Incrementing
nonalphanumerics uses the underlying character set’s collating sequence.</p>

<p>If the increment generates a “carry,” the character to the left of it is
incremented. This process repeats until there is no carry, adding an
additional character if necessary.</p>

<pre class="ruby"><span class="ruby-string">"abcd"</span>.<span class="ruby-identifier">succ</span>        <span class="ruby-comment">#=&gt; "abce"</span>
<span class="ruby-string">"THX1138"</span>.<span class="ruby-identifier">succ</span>     <span class="ruby-comment">#=&gt; "THX1139"</span>
<span class="ruby-string">"&lt;&lt;koala&gt;&gt;"</span>.<span class="ruby-identifier">succ</span>   <span class="ruby-comment">#=&gt; "&lt;&lt;koalb&gt;&gt;"</span>
<span class="ruby-string">"1999zzz"</span>.<span class="ruby-identifier">succ</span>     <span class="ruby-comment">#=&gt; "2000aaa"</span>
<span class="ruby-string">"ZZZ9999"</span>.<span class="ruby-identifier">succ</span>     <span class="ruby-comment">#=&gt; "AAAA0000"</span>
<span class="ruby-string">"***"</span>.<span class="ruby-identifier">succ</span>         <span class="ruby-comment">#=&gt; "**+"</span>
</pre>
            

            
            <div class="method-source-code" id="next-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_str_succ(VALUE orig)
{
    VALUE str;
    str = rb_str_new_with_class(orig, RSTRING_PTR(orig), RSTRING_LEN(orig));
    rb_enc_cr_str_copy_for_substr(str, orig);
    OBJ_INFECT(str, orig);
    return str_succ(str);
}
            </pre> 
            </div><!-- next-source -->
            
          </div>

          

          
        </div><!-- next-method -->
      
        <div id="next-21-method" class="method-detail ">
          <a name="method-i-next-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">next!   → str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Equivalent to <code>String#succ</code>, but modifies the receiver in place.</p>
            

            
            <div class="method-source-code" id="next-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_succ_bang(VALUE str)
{
    rb_str_modify(str);
    str_succ(str);
    return str;
}
            </pre> 
            </div><!-- next-21-source -->
            
          </div>

          

          
        </div><!-- next-21-method -->
      
        <div id="oct-method" class="method-detail ">
          <a name="method-i-oct"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">oct   → integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Treats leading characters of <em>str</em> as a string of octal digits (with
an optional sign) and returns the corresponding number.  Returns 0 if the
conversion fails.</p>

<pre class="ruby"><span class="ruby-string">"123"</span>.<span class="ruby-identifier">oct</span>       <span class="ruby-comment">#=&gt; 83</span>
<span class="ruby-string">"-377"</span>.<span class="ruby-identifier">oct</span>      <span class="ruby-comment">#=&gt; -255</span>
<span class="ruby-string">"bad"</span>.<span class="ruby-identifier">oct</span>       <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-string">"0377bad"</span>.<span class="ruby-identifier">oct</span>   <span class="ruby-comment">#=&gt; 255</span>
</pre>
            

            
            <div class="method-source-code" id="oct-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_oct(VALUE str)
{
    return rb_str_to_inum(str, -8, FALSE);
}
            </pre> 
            </div><!-- oct-source -->
            
          </div>

          

          
        </div><!-- oct-method -->
      
        <div id="ord-method" class="method-detail ">
          <a name="method-i-ord"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ord   → integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Return the <code>Integer</code> ordinal of a one-character string.</p>

<pre class="ruby"><span class="ruby-string">"a"</span>.<span class="ruby-identifier">ord</span>         <span class="ruby-comment">#=&gt; 97</span>
</pre>
            

            
            <div class="method-source-code" id="ord-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_str_ord(VALUE s)
{
    unsigned int c;

    c = rb_enc_codepoint(RSTRING_PTR(s), RSTRING_END(s), STR_ENC_GET(s));
    return UINT2NUM(c);
}
            </pre> 
            </div><!-- ord-source -->
            
          </div>

          

          
        </div><!-- ord-method -->
      
        <div id="partition-method" class="method-detail ">
          <a name="method-i-partition"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">partition(sep)              → [head, sep, tail]</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">partition(regexp)           → [head, match, tail]</span>
            
          </div>
          
          
          <div>
  
            
            <p>Searches <em>sep</em> or pattern (<em>regexp</em>) in the string and
returns the part before it, the match, and the part after it. If it is not
found, returns two empty strings and <em>str</em>.</p>

<pre class="ruby"><span class="ruby-string">"hello"</span>.<span class="ruby-identifier">partition</span>(<span class="ruby-string">"l"</span>)         <span class="ruby-comment">#=&gt; ["he", "l", "lo"]</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">partition</span>(<span class="ruby-string">"x"</span>)         <span class="ruby-comment">#=&gt; ["hello", "", ""]</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">partition</span>(<span class="ruby-regexp">/.l/</span>)        <span class="ruby-comment">#=&gt; ["h", "el", "lo"]</span>
</pre>
            

            
            <div class="method-source-code" id="partition-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_partition(VALUE str, VALUE sep)
{
    long pos;

    sep = get_pat_quoted(sep, 0);
    if (RB_TYPE_P(sep, T_REGEXP)) {
        pos = rb_reg_search(sep, str, 0, 0);
        if (pos &lt; 0) {
          failed:
            return rb_ary_new3(3, str, str_new_empty(str), str_new_empty(str));
        }
        sep = rb_str_subpat(str, sep, INT2FIX(0));
        if (pos == 0 &amp;&amp; RSTRING_LEN(sep) == 0) goto failed;
    }
    else {
        pos = rb_str_index(str, sep, 0);
        if (pos &lt; 0) goto failed;
    }
    return rb_ary_new3(3, rb_str_subseq(str, 0, pos),
                          sep,
                          rb_str_subseq(str, pos+RSTRING_LEN(sep),
                                             RSTRING_LEN(str)-pos-RSTRING_LEN(sep)));
}
            </pre> 
            </div><!-- partition-source -->
            
          </div>

          

          
        </div><!-- partition-method -->
      
        <div id="prepend-method" class="method-detail ">
          <a name="method-i-prepend"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">prepend(other_str)  → str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Prepend—Prepend the given string to <em>str</em>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-string">"world"</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">prepend</span>(<span class="ruby-string">"hello "</span>) <span class="ruby-comment">#=&gt; "hello world"</span>
<span class="ruby-identifier">a</span>                   <span class="ruby-comment">#=&gt; "hello world"</span>
</pre>
            

            
            <div class="method-source-code" id="prepend-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_prepend(VALUE str, VALUE str2)
{
    StringValue(str2);
    StringValue(str);
    rb_str_update(str, 0L, 0L, str2);
    return str;
}
            </pre> 
            </div><!-- prepend-source -->
            
          </div>

          

          
        </div><!-- prepend-method -->
      
        <div id="replace-method" class="method-detail ">
          <a name="method-i-replace"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">replace(other_str)   → str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Replaces the contents and taintedness of <em>str</em> with the
corresponding values in <em>other_str</em>.</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">"hello"</span>         <span class="ruby-comment">#=&gt; "hello"</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">replace</span> <span class="ruby-string">"world"</span>   <span class="ruby-comment">#=&gt; "world"</span>
</pre>
            

            
            <div class="method-source-code" id="replace-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_str_replace(VALUE str, VALUE str2)
{
    str_modifiable(str);
    if (str == str2) return str;

    StringValue(str2);
    str_discard(str);
    return str_replace(str, str2);
}
            </pre> 
            </div><!-- replace-source -->
            
          </div>

          

          
        </div><!-- replace-method -->
      
        <div id="reverse-method" class="method-detail ">
          <a name="method-i-reverse"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reverse   → new_str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new string with the characters from <em>str</em> in reverse
order.</p>

<pre class="ruby"><span class="ruby-string">"stressed"</span>.<span class="ruby-identifier">reverse</span>   <span class="ruby-comment">#=&gt; "desserts"</span>
</pre>
            

            
            <div class="method-source-code" id="reverse-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_reverse(VALUE str)
{
    rb_encoding *enc;
    VALUE rev;
    char *s, *e, *p;
    int single = 1;

    if (RSTRING_LEN(str) &lt;= 1) return rb_str_dup(str);
    enc = STR_ENC_GET(str);
    rev = rb_str_new_with_class(str, 0, RSTRING_LEN(str));
    s = RSTRING_PTR(str); e = RSTRING_END(str);
    p = RSTRING_END(rev);

    if (RSTRING_LEN(str) &gt; 1) {
        if (single_byte_optimizable(str)) {
            while (s &lt; e) {
                *--p = *s++;
            }
        }
        else if (ENC_CODERANGE(str) == ENC_CODERANGE_VALID) {
            while (s &lt; e) {
                int clen = rb_enc_fast_mbclen(s, e, enc);

                if (clen &gt; 1 || (*s &amp; 0x80)) single = 0;
                p -= clen;
                memcpy(p, s, clen);
                s += clen;
            }
        }
        else {
            while (s &lt; e) {
                int clen = rb_enc_mbclen(s, e, enc);

                if (clen &gt; 1 || (*s &amp; 0x80)) single = 0;
                p -= clen;
                memcpy(p, s, clen);
                s += clen;
            }
        }
    }
    STR_SET_LEN(rev, RSTRING_LEN(str));
    OBJ_INFECT(rev, str);
    if (ENC_CODERANGE(str) == ENC_CODERANGE_UNKNOWN) {
        if (single) {
            ENC_CODERANGE_SET(str, ENC_CODERANGE_7BIT);
        }
        else {
            ENC_CODERANGE_SET(str, ENC_CODERANGE_VALID);
        }
    }
    rb_enc_cr_str_copy_for_substr(rev, str);

    return rev;
}
            </pre> 
            </div><!-- reverse-source -->
            
          </div>

          

          
        </div><!-- reverse-method -->
      
        <div id="reverse-21-method" class="method-detail ">
          <a name="method-i-reverse-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reverse!   → str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reverses <em>str</em> in place.</p>
            

            
            <div class="method-source-code" id="reverse-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_reverse_bang(VALUE str)
{
    if (RSTRING_LEN(str) &gt; 1) {
        if (single_byte_optimizable(str)) {
            char *s, *e, c;

            str_modify_keep_cr(str);
            s = RSTRING_PTR(str);
            e = RSTRING_END(str) - 1;
            while (s &lt; e) {
                c = *s;
                *s++ = *e;
                *e-- = c;
            }
        }
        else {
            rb_str_shared_replace(str, rb_str_reverse(str));
        }
    }
    else {
        str_modify_keep_cr(str);
    }
    return str;
}
            </pre> 
            </div><!-- reverse-21-source -->
            
          </div>

          

          
        </div><!-- reverse-21-method -->
      
        <div id="rindex-method" class="method-detail ">
          <a name="method-i-rindex"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rindex(substring [, fixnum])   → fixnum or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">rindex(regexp [, fixnum])   → fixnum or nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the index of the last occurrence of the given <em>substring</em> or
pattern (<em>regexp</em>) in <em>str</em>. Returns <code>nil</code> if not
found. If the second parameter is present, it specifies the position in the
string to end the search—characters beyond this point will not be
considered.</p>

<pre class="ruby"><span class="ruby-string">"hello"</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-string">'e'</span>)             <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-string">'l'</span>)             <span class="ruby-comment">#=&gt; 3</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-string">'a'</span>)             <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-value">?e</span>)              <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-regexp">/[aeiou]/</span>, <span class="ruby-value">-2</span>)   <span class="ruby-comment">#=&gt; 1</span>
</pre>
            

            
            <div class="method-source-code" id="rindex-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_rindex_m(int argc, VALUE *argv, VALUE str)
{
    VALUE sub;
    VALUE vpos;
    rb_encoding *enc = STR_ENC_GET(str);
    long pos, len = str_strlen(str, enc); /* str's enc */

    if (rb_scan_args(argc, argv, "11", &amp;sub, &amp;vpos) == 2) {
        pos = NUM2LONG(vpos);
        if (pos &lt; 0) {
            pos += len;
            if (pos &lt; 0) {
                if (RB_TYPE_P(sub, T_REGEXP)) {
                    rb_backref_set(Qnil);
                }
                return Qnil;
            }
        }
        if (pos &gt; len) pos = len;
    }
    else {
        pos = len;
    }

    if (SPECIAL_CONST_P(sub)) goto generic;
    switch (BUILTIN_TYPE(sub)) {
      case T_REGEXP:
        /* enc = rb_get_check(str, sub); */
        pos = str_offset(RSTRING_PTR(str), RSTRING_END(str), pos,
                         enc, single_byte_optimizable(str));

        if (!RREGEXP(sub)-&gt;ptr || RREGEXP_SRC_LEN(sub)) {
            pos = rb_reg_search(sub, str, pos, 1);
            pos = rb_str_sublen(str, pos);
        }
        if (pos &gt;= 0) return LONG2NUM(pos);
        break;

      generic:
      default: {
        VALUE tmp;

        tmp = rb_check_string_type(sub);
        if (NIL_P(tmp)) {
            rb_raise(rb_eTypeError, "type mismatch: %s given",
                     rb_obj_classname(sub));
        }
        sub = tmp;
      }
        /* fall through */
      case T_STRING:
        pos = rb_str_rindex(str, sub, pos);
        if (pos &gt;= 0) return LONG2NUM(pos);
        break;
    }
    return Qnil;
}
            </pre> 
            </div><!-- rindex-source -->
            
          </div>

          

          
        </div><!-- rindex-method -->
      
        <div id="rjust-method" class="method-detail ">
          <a name="method-i-rjust"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rjust(integer, padstr=' ')   → new_str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>If <em>integer</em> is greater than the length of <em>str</em>, returns a
new <code>String</code> of length <em>integer</em> with <em>str</em> right
justified and padded with <em>padstr</em>; otherwise, returns <em>str</em>.</p>

<pre class="ruby"><span class="ruby-string">"hello"</span>.<span class="ruby-identifier">rjust</span>(<span class="ruby-value">4</span>)            <span class="ruby-comment">#=&gt; "hello"</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">rjust</span>(<span class="ruby-value">20</span>)           <span class="ruby-comment">#=&gt; "               hello"</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">rjust</span>(<span class="ruby-value">20</span>, <span class="ruby-string">'1234'</span>)   <span class="ruby-comment">#=&gt; "123412341234123hello"</span>
</pre>
            

            
            <div class="method-source-code" id="rjust-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_rjust(int argc, VALUE *argv, VALUE str)
{
    return rb_str_justify(argc, argv, str, 'r');
}
            </pre> 
            </div><!-- rjust-source -->
            
          </div>

          

          
        </div><!-- rjust-method -->
      
        <div id="rpartition-method" class="method-detail ">
          <a name="method-i-rpartition"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rpartition(sep)             → [head, sep, tail]</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">rpartition(regexp)          → [head, match, tail]</span>
            
          </div>
          
          
          <div>
  
            
            <p>Searches <em>sep</em> or pattern (<em>regexp</em>) in the string from the
end of the string, and returns the part before it, the match, and the part
after it. If it is not found, returns two empty strings and <em>str</em>.</p>

<pre class="ruby"><span class="ruby-string">"hello"</span>.<span class="ruby-identifier">rpartition</span>(<span class="ruby-string">"l"</span>)         <span class="ruby-comment">#=&gt; ["hel", "l", "o"]</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">rpartition</span>(<span class="ruby-string">"x"</span>)         <span class="ruby-comment">#=&gt; ["", "", "hello"]</span>
<span class="ruby-string">"hello"</span>.<span class="ruby-identifier">rpartition</span>(<span class="ruby-regexp">/.l/</span>)        <span class="ruby-comment">#=&gt; ["he", "ll", "o"]</span>
</pre>
            

            
            <div class="method-source-code" id="rpartition-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_str_rpartition(VALUE str, VALUE sep)
{
    long pos = RSTRING_LEN(str);
    int regex = FALSE;

    if (RB_TYPE_P(sep, T_REGEXP)) {
        pos = rb_reg_search(sep, str, pos, 1);
        regex = TRUE;
    }
    else {
        VALUE tmp;

        tmp = rb_check_string_type(sep);
        if (NIL_P(tmp)) {
            rb_