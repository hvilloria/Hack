<!--?xml version="1.0" encoding="UTF-8"?-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>
  <!-- classpage -- >
    <!-- RD version: 0.35.3  -->
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
  <meta name="description" content="  Module : Enumerable  -   Ruby 2.2.0 ">
  <meta content="2016-08-21 15:31:38 -0500" http-equiv="change-date">
  <!-- rel_prefix  = ''  ENV['RDOC_FOR_WEBSITE']   = true-->
    
    
    
  <!-- rel_prefix = '.'   asset_rel_prefix = ''  --> 
  <title>Module: Enumerable (Ruby 2.2.0) </title>
  <link rel="stylesheet" href="arreglo_doc_files/associated.css" type="text/css">
  <!-- link rel="stylesheet" href=".css/obf.css"  -->
  <link rel="stylesheet" href="arreglo_doc_files/inuit.css">
  <link rel="stylesheet" href="arreglo_doc_files/grid.css">
  <link rel="stylesheet" href="arreglo_doc_files/2011.css" type="text/css">
  <link rel="stylesheet" href="arreglo_doc_files/rdoc.css" type="text/css">


  <script src="arreglo_doc_files/analytics.js" async=""></script><script src="arreglo_doc_files/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="arreglo_doc_files/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="arreglo_doc_files/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="arreglo_doc_files/rubydoc.js" type="text/javascript" charset="utf-8"></script> 


   
<script src="arreglo_doc_files/highlight.js"></script>
<script> 
  hljs.tabReplace = '  ';
  hljs.initHighlightingOnLoad();
  </script> 

  <style type="text/css">

    #vulns-alert #vulns{
      background-color: #c33 ! important;
      width: 100%;
      text-align: center;
   }
   
   #vulns-alert #vulns a {
    color: #F99 ! important;
   }
 </style>

   <link rel="stylesheet" href="arreglo_doc_files/extra.css" type="text/css">
  <script src="arreglo_doc_files/extra.js"></script>


<script data-timestamp="1471956963042" src="arreglo_doc_files/embed.js"></script><script src="arreglo_doc_files/C6AILKT.html" type="text/javascript" id="_carbonads_projs"></script></head>

<body id="top" class="module rdocstar">

<div id="actionbar">
<div class="wrapper">
  <ul class="grids g0">
	<li class="grid-2"><a href="http://ruby-doc.org/" target="_top">Home</a></li>
	<li class="grid-2"><a href="http://ruby-doc.org/core-2.2.0" target="_top">Core 2.2.0</a></li>
	<li class="grid-2"><a href="http://ruby-doc.org/stdlib-2.2.0" target="_top">Std-lib 2.2.0</a></li>

	 <!-- li class='grid-2' ><a href='/zems' target='_top' >Zems</a></li -->
   <li class="grid-2"><a href="http://ruby-doc.org/downloads" target="_top">Downloads</a></li>
	 <li class="grid-5 right" id="rd-action-search"><form id="searchbox_011815814100681837392:wnccv6st5qk" action="http://ruby-doc.com/search.html"><input name="cx" value="011815814100681837392:wnccv6st5qk" type="hidden"><input id="rd-search-input" name="q" size="20" type="text">&nbsp;&nbsp;<input name="sa" value="Search" type="submit"><input name="cof" value="FORID:9" type="hidden"></form></li>
	</ul>
</div>
<span id="vulns-alert"><!-- void  -->
</span>
<!-- VERSION HEADER for 2.2.0 NOT FOUND --></div> <!-- end action bar -->
 <div class="wrapper">
  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="http://ruby-doc.org/core-2.2.0/index.html">Home</a>
          <a href="http://ruby-doc.org/core-2.2.0/index.html#classes">Classes</a>
          <a href="http://ruby-doc.org/core-2.2.0/index.html#methods">Methods</a>
          
          
          <!-- br><a id='alternateFormatLink' class='rotate' href="#" onclick='matchingYardUrl()'>YARD version</a -->
          
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul id="file-metadata">

          
          
          
          <li class="in-file">enum.c</li>      
            
          
          <li class="in-file">enumerator.c</li>      
            
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      

      

      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-i-all-3F">#all?</a></li>
          
          <li><a href="#method-i-any-3F">#any?</a></li>
          
          <li><a href="#method-i-chunk">#chunk</a></li>
          
          <li><a href="#method-i-collect">#collect</a></li>
          
          <li><a href="#method-i-collect_concat">#collect_concat</a></li>
          
          <li><a href="#method-i-count">#count</a></li>
          
          <li><a href="#method-i-cycle">#cycle</a></li>
          
          <li><a href="#method-i-detect">#detect</a></li>
          
          <li><a href="#method-i-drop">#drop</a></li>
          
          <li><a href="#method-i-drop_while">#drop_while</a></li>
          
          <li><a href="#method-i-each_cons">#each_cons</a></li>
          
          <li><a href="#method-i-each_entry">#each_entry</a></li>
          
          <li><a href="#method-i-each_slice">#each_slice</a></li>
          
          <li><a href="#method-i-each_with_index">#each_with_index</a></li>
          
          <li><a href="#method-i-each_with_object">#each_with_object</a></li>
          
          <li><a href="#method-i-entries">#entries</a></li>
          
          <li><a href="#method-i-find">#find</a></li>
          
          <li><a href="#method-i-find_all">#find_all</a></li>
          
          <li><a href="#method-i-find_index">#find_index</a></li>
          
          <li><a href="#method-i-first">#first</a></li>
          
          <li><a href="#method-i-flat_map">#flat_map</a></li>
          
          <li><a href="#method-i-grep">#grep</a></li>
          
          <li><a href="#method-i-group_by">#group_by</a></li>
          
          <li><a href="#method-i-include-3F">#include?</a></li>
          
          <li><a href="#method-i-inject">#inject</a></li>
          
          <li><a href="#method-i-lazy">#lazy</a></li>
          
          <li><a href="#method-i-map">#map</a></li>
          
          <li><a href="#method-i-max">#max</a></li>
          
          <li><a href="#method-i-max_by">#max_by</a></li>
          
          <li><a href="#method-i-member-3F">#member?</a></li>
          
          <li><a href="#method-i-min">#min</a></li>
          
          <li><a href="#method-i-min_by">#min_by</a></li>
          
          <li><a href="#method-i-minmax">#minmax</a></li>
          
          <li><a href="#method-i-minmax_by">#minmax_by</a></li>
          
          <li><a href="#method-i-none-3F">#none?</a></li>
          
          <li><a href="#method-i-one-3F">#one?</a></li>
          
          <li><a href="#method-i-partition">#partition</a></li>
          
          <li><a href="#method-i-reduce">#reduce</a></li>
          
          <li><a href="#method-i-reject">#reject</a></li>
          
          <li><a href="#method-i-reverse_each">#reverse_each</a></li>
          
          <li><a href="#method-i-select">#select</a></li>
          
          <li><a href="#method-i-slice_after">#slice_after</a></li>
          
          <li><a href="#method-i-slice_before">#slice_before</a></li>
          
          <li><a href="#method-i-slice_when">#slice_when</a></li>
          
          <li><a href="#method-i-sort">#sort</a></li>
          
          <li><a href="#method-i-sort_by">#sort_by</a></li>
          
          <li><a href="#method-i-take">#take</a></li>
          
          <li><a href="#method-i-take_while">#take_while</a></li>
          
          <li><a href="#method-i-to_a">#to_a</a></li>
          
          <li><a href="#method-i-to_h">#to_h</a></li>
          
          <li><a href="#method-i-zip">#zip</a></li>
          
        </ul>
      </div>
      

      
    </div>

    <div id="project-metadata">
      
      
      <div id="fileindex-section" class="section project-section">
        <h3 class="section-header">Files</h3>
        <ul id="files">
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/_lib/racc/rdoc/grammar_en_rdoc.html">grammar.en.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/_test/rdoc/test_ja_rdoc.html">test.ja.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/doc/contributing_rdoc.html">contributing.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/doc/contributors_rdoc.html">contributors.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/doc/dtrace_probes_rdoc.html">dtrace_probes.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/doc/globals_rdoc.html">globals.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/doc/keywords_rdoc.html">keywords.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/doc/maintainers_rdoc.html">maintainers.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/doc/marshal_rdoc.html">marshal.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/doc/regexp_rdoc.html">regexp.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/doc/security_rdoc.html">security.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/doc/standard_library_rdoc.html">standard_library.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/doc/syntax_rdoc.html">syntax.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/doc/syntax/assignment_rdoc.html">assignment.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/doc/syntax/calling_methods_rdoc.html">calling_methods.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/doc/syntax/control_expressions_rdoc.html">control_expressions.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/doc/syntax/exceptions_rdoc.html">exceptions.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/doc/syntax/literals_rdoc.html">literals.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/doc/syntax/methods_rdoc.html">methods.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/doc/syntax/miscellaneous_rdoc.html">miscellaneous.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/doc/syntax/modules_and_classes_rdoc.html">modules_and_classes.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/doc/syntax/precedence_rdoc.html">precedence.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/doc/syntax/refinements_rdoc.html">refinements.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/sample/drb/README_ja_rdoc.html">README.ja.rdoc</a></li>
        
          
          <li class="file"><a href="http://ruby-doc.org/core-2.2.0/sample/drb/README_rdoc.html">README.rdoc</a></li>
        
        </ul>
      </div>
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="arreglo_doc_files/find.png" alt="[+]" title="show/hide quicksearch" height="16" width="16"></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input name="quicksearch" class="quicksearch-field" type="text">
        </fieldset>
        </form>

        <ul class="link-list">
          
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/ArgumentError.html">ArgumentError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Array.html">Array</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/BasicObject.html">BasicObject</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Bignum.html">Bignum</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Binding.html">Binding</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Class.html">Class</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Comparable.html">Comparable</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Complex.html">Complex</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Complex/compatible.html">Complex::compatible</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/ConditionVariable.html">ConditionVariable</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Continuation.html">Continuation</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Data.html">Data</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Dir.html">Dir</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/ENV.html">ENV</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/EOFError.html">EOFError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Encoding.html">Encoding</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Encoding/CompatibilityError.html">Encoding::CompatibilityError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Encoding/Converter.html">Encoding::Converter</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Encoding/ConverterNotFoundError.html">Encoding::ConverterNotFoundError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Encoding/InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Encoding/UndefinedConversionError.html">Encoding::UndefinedConversionError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/EncodingError.html">EncodingError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Enumerable.html">Enumerable</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Enumerator.html">Enumerator</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Enumerator/Generator.html">Enumerator::Generator</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Enumerator/Lazy.html">Enumerator::Lazy</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Enumerator/Yielder.html">Enumerator::Yielder</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Errno.html">Errno</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Exception.html">Exception</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/FalseClass.html">FalseClass</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Fiber.html">Fiber</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/FiberError.html">FiberError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/File.html">File</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/File/Constants.html">File::Constants</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/File/Stat.html">File::Stat</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/FileTest.html">FileTest</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Fixnum.html">Fixnum</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Float.html">Float</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/FloatDomainError.html">FloatDomainError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/GC.html">GC</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/GC/Profiler.html">GC::Profiler</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Hash.html">Hash</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/IO.html">IO</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/IO/EAGAINWaitReadable.html">IO::EAGAINWaitReadable</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/IO/EAGAINWaitWritable.html">IO::EAGAINWaitWritable</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/IO/EINPROGRESSWaitReadable.html">IO::EINPROGRESSWaitReadable</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/IO/EINPROGRESSWaitWritable.html">IO::EINPROGRESSWaitWritable</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/IO/EWOULDBLOCKWaitReadable.html">IO::EWOULDBLOCKWaitReadable</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/IO/EWOULDBLOCKWaitWritable.html">IO::EWOULDBLOCKWaitWritable</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/IO/WaitReadable.html">IO::WaitReadable</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/IO/WaitWritable.html">IO::WaitWritable</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/IOError.html">IOError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/IndexError.html">IndexError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Integer.html">Integer</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Interrupt.html">Interrupt</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Kernel.html">Kernel</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/KeyError.html">KeyError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/LoadError.html">LoadError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/LocalJumpError.html">LocalJumpError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Marshal.html">Marshal</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/MatchData.html">MatchData</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Math.html">Math</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Math/DomainError.html">Math::DomainError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Method.html">Method</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Module.html">Module</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Mutex.html">Mutex</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/NameError.html">NameError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/NilClass.html">NilClass</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/NoMemoryError.html">NoMemoryError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/NoMethodError.html">NoMethodError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/NotImplementedError.html">NotImplementedError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Numeric.html">Numeric</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Object.html">Object</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/ObjectSpace.html">ObjectSpace</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/ObjectSpace/WeakMap.html">ObjectSpace::WeakMap</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Proc.html">Proc</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Process.html">Process</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Process/GID.html">Process::GID</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Process/Status.html">Process::Status</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Process/Sys.html">Process::Sys</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Process/UID.html">Process::UID</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Process/Waiter.html">Process::Waiter</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Queue.html">Queue</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Random.html">Random</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Range.html">Range</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/RangeError.html">RangeError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Rational.html">Rational</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Rational/compatible.html">Rational::compatible</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Regexp.html">Regexp</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/RegexpError.html">RegexpError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/RubyVM.html">RubyVM</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/RubyVM/Env.html">RubyVM::Env</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/RubyVM/InstructionSequence.html">RubyVM::InstructionSequence</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/RuntimeError.html">RuntimeError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/ScriptError.html">ScriptError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/SecurityError.html">SecurityError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Signal.html">Signal</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/SignalException.html">SignalException</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/SizedQueue.html">SizedQueue</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/StandardError.html">StandardError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/StopIteration.html">StopIteration</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/String.html">String</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Struct.html">Struct</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Symbol.html">Symbol</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/SyntaxError.html">SyntaxError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/SystemCallError.html">SystemCallError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/SystemExit.html">SystemExit</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/SystemStackError.html">SystemStackError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Thread.html">Thread</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Thread/Backtrace/Location.html">Thread::Backtrace::Location</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/ThreadError.html">ThreadError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/ThreadGroup.html">ThreadGroup</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/Time.html">Time</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/TracePoint.html">TracePoint</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/TrueClass.html">TrueClass</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/TypeError.html">TypeError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/UnboundMethod.html">UnboundMethod</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/UncaughtThrowError.html">UncaughtThrowError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/ZeroDivisionError.html">ZeroDivisionError</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/fatal.html">fatal</a></li>
        
          
          
          <li><a href="http://ruby-doc.org/core-2.2.0/unknown.html">unknown</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
      <div id="debugging-toggle"><img src="arreglo_doc_files/bug.png" alt="toggle debugging" height="16" width="16"></div>
      
    </div>
  </div> <!-- metadata -->
  <div class="adzbox" id="azk83167">
    
   <div id="carbonads-container"><div class="carbonad">
    <script async="" type="text/javascript" src="arreglo_doc_files/carbon.js" id="_carbonads_js">
      </script>
  </div></div>

   
  </div> 
  <div id="documentation">
    <h1 class="module">Enumerable</h1>

    <div id="description" class="description">
      
<p>The <code>Enumerable</code> mixin provides collection classes with several
traversal and searching methods, and with the ability to sort. The class
must provide a method <code>each</code>, which yields successive members of
the collection. If <code>Enumerable#max</code>, <code>#min</code>, or
<code>#sort</code> is used, the objects in the collection must also
implement a meaningful <code>&lt;=&gt;</code> operator, as these methods
rely on an ordering between members of the collection.</p>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      

      

      <!-- Methods -->
      
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="all-3F-method" class="method-detail ">
          <a name="method-i-all-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">all? [{ |obj| block } ]   → true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Passes each element of the collection to the given block. The method
returns <code>true</code> if the block never returns <code>false</code> or
<code>nil</code>. If the block is not given, Ruby adds an implicit block of
<code>{ |obj| obj }</code> which will cause <a href="http://ruby-doc.org/core-2.2.0/Enumerable.html#method-i-all-3F">all?</a> to return <code>true</code>
when none of the collection members are <code>false</code> or
<code>nil</code>.</p>

<pre class="ruby"><span class="ruby-node">%w[ant bear cat]</span>.<span class="ruby-identifier">all?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">3</span> } <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-node">%w[ant bear cat]</span>.<span class="ruby-identifier">all?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">4</span> } <span class="ruby-comment">#=&gt; false</span>
[<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">true</span>, <span class="ruby-value">99</span>].<span class="ruby-identifier">all?</span>                              <span class="ruby-comment">#=&gt; false</span>
</pre>
            

            
            <div class="method-source-code" id="all-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_all(VALUE obj)
{
    NODE *memo = NEW_MEMO(Qtrue, 0, 0);
    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(all), (VALUE)memo);
    return memo-&gt;u1.value;
}
            </pre> 
            </div><!-- all-3F-source -->
            
          </div>

          

          
        </div><!-- all-3F-method -->
      
        <div id="any-3F-method" class="method-detail ">
          <a name="method-i-any-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">any? [{ |obj| block }]   → true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Passes each element of the collection to the given block. The method
returns <code>true</code> if the block ever returns a value other than
<code>false</code> or <code>nil</code>. If the block is not given, Ruby
adds an implicit block of <code>{ |obj| obj }</code> that will cause <a href="http://ruby-doc.org/core-2.2.0/Enumerable.html#method-i-any-3F">any?</a> to return <code>true</code>
if at least one of the collection members is not <code>false</code> or
<code>nil</code>.</p>

<pre class="ruby"><span class="ruby-node">%w[ant bear cat]</span>.<span class="ruby-identifier">any?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">3</span> } <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-node">%w[ant bear cat]</span>.<span class="ruby-identifier">any?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">4</span> } <span class="ruby-comment">#=&gt; true</span>
[<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">true</span>, <span class="ruby-value">99</span>].<span class="ruby-identifier">any?</span>                              <span class="ruby-comment">#=&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="any-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_any(VALUE obj)
{
    NODE *memo = NEW_MEMO(Qfalse, 0, 0);
    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(any), (VALUE)memo);
    return memo-&gt;u1.value;
}
            </pre> 
            </div><!-- any-3F-source -->
            
          </div>

          

          
        </div><!-- any-3F-method -->
      
        <div id="chunk-method" class="method-detail ">
          <a name="method-i-chunk"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">chunk { |elt| ... }                       → an_enumerator</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">chunk(initial_state) { |elt, state| ... } → an_enumerator (deprecated)</span>
            
          </div>
          
          
          <div>
  
            
            <p>Enumerates over the items, chunking them together based on the return value
of the block.</p>

<p>Consecutive elements which return the same block value are chunked
together.</p>

<p>For example, consecutive even numbers and odd numbers can be chunked as
follows.</p>

<pre class="ruby">[<span class="ruby-value">3</span>, <span class="ruby-value">1</span>, <span class="ruby-value">4</span>, <span class="ruby-value">1</span>, <span class="ruby-value">5</span>, <span class="ruby-value">9</span>, <span class="ruby-value">2</span>, <span class="ruby-value">6</span>, <span class="ruby-value">5</span>, <span class="ruby-value">3</span>, <span class="ruby-value">5</span>].<span class="ruby-identifier">chunk</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">n</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">n</span>.<span class="ruby-identifier">even?</span>
}.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">even</span>, <span class="ruby-identifier">ary</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">p</span> [<span class="ruby-identifier">even</span>, <span class="ruby-identifier">ary</span>]
}
<span class="ruby-comment">#=&gt; [false, [3, 1]]</span>
<span class="ruby-comment">#   [true, [4]]</span>
<span class="ruby-comment">#   [false, [1, 5, 9]]</span>
<span class="ruby-comment">#   [true, [2, 6]]</span>
<span class="ruby-comment">#   [false, [5, 3, 5]]</span>
</pre>

<p>This method is especially useful for sorted series of elements. The
following example counts words for each initial letter.</p>

<pre class="ruby"><span class="ruby-identifier">open</span>(<span class="ruby-string">"/usr/share/dict/words"</span>, <span class="ruby-string">"r:iso-8859-1"</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">chunk</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">ord</span> }.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">ch</span>, <span class="ruby-identifier">lines</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> [<span class="ruby-identifier">ch</span>.<span class="ruby-identifier">chr</span>, <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">length</span>] }
}
<span class="ruby-comment">#=&gt; ["\n", 1]</span>
<span class="ruby-comment">#   ["A", 1327]</span>
<span class="ruby-comment">#   ["B", 1372]</span>
<span class="ruby-comment">#   ["C", 1507]</span>
<span class="ruby-comment">#   ["D", 791]</span>
<span class="ruby-comment">#   ...</span>
</pre>

<p>The following key values have special meaning:</p>
<ul><li>
<p><code>nil</code> and <code>:_separator</code> specifies that the elements
should be dropped.</p>
</li><li>
<p><code>:_alone</code> specifies that the element should be chunked by
itself.</p>
</li></ul>

<p>Any other symbols that begin with an underscore will raise an error:</p>

<pre class="ruby"><span class="ruby-identifier">items</span>.<span class="ruby-identifier">chunk</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">item</span><span class="ruby-operator">|</span> :<span class="ruby-identifier">_underscore</span> }
<span class="ruby-comment">#=&gt; RuntimeError: symbols beginning with an underscore are reserved</span>
</pre>

<p><code>nil</code> and <code>:_separator</code> can be used to ignore some
elements.</p>

<p>For example, the sequence of hyphens in svn log can be eliminated as
follows:</p>

<pre class="ruby"><span class="ruby-identifier">sep</span> = <span class="ruby-string">"-"</span><span class="ruby-operator">*</span><span class="ruby-value">72</span> <span class="ruby-operator">+</span> <span class="ruby-string">"\n"</span>
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">popen</span>(<span class="ruby-string">"svn log README"</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">chunk</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">line</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">sep</span> <span class="ruby-operator">||</span> <span class="ruby-keyword">nil</span>
  }.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">_</span>, <span class="ruby-identifier">lines</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">pp</span> <span class="ruby-identifier">lines</span>
  }
}
<span class="ruby-comment">#=&gt; ["r20018 | knu | 2008-10-29 13:20:42 +0900 (Wed, 29 Oct 2008) | 2 lines\n",</span>
<span class="ruby-comment">#    "\n",</span>
<span class="ruby-comment">#    "* README, README.ja: Update the portability section.\n",</span>
<span class="ruby-comment">#    "\n"]</span>
<span class="ruby-comment">#   ["r16725 | knu | 2008-05-31 23:34:23 +0900 (Sat, 31 May 2008) | 2 lines\n",</span>
<span class="ruby-comment">#    "\n",</span>
<span class="ruby-comment">#    "* README, README.ja: Add a note about default C flags.\n",</span>
<span class="ruby-comment">#    "\n"]</span>
<span class="ruby-comment">#   ...</span>
</pre>

<p>Paragraphs separated by empty lines can be parsed as follows:</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">foreach</span>(<span class="ruby-string">"README"</span>).<span class="ruby-identifier">chunk</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
  <span class="ruby-regexp">/\A\s*\z/</span> <span class="ruby-operator">!~</span> <span class="ruby-identifier">line</span> <span class="ruby-operator">||</span> <span class="ruby-keyword">nil</span>
}.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">_</span>, <span class="ruby-identifier">lines</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">pp</span> <span class="ruby-identifier">lines</span>
}
</pre>

<p><code>:_alone</code> can be used to force items into their own chunk. For
example, you can put lines that contain a URL by themselves, and chunk the
rest of the lines together, like this:</p>

<pre class="ruby"><span class="ruby-identifier">pattern</span> = <span class="ruby-regexp">/http/</span>
<span class="ruby-identifier">open</span>(<span class="ruby-identifier">filename</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">chunk</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span> <span class="ruby-identifier">line</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">pattern</span> <span class="ruby-operator">?</span> :<span class="ruby-identifier">_alone</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">true</span> }.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">lines</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">pp</span> <span class="ruby-identifier">lines</span>
  }
}
</pre>
            

            
            <div class="method-source-code" id="chunk-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_chunk(int argc, VALUE *argv, VALUE enumerable)
{
    VALUE initial_state;
    VALUE enumerator;
    int n;

    if (!rb_block_given_p())
        rb_raise(rb_eArgError, "no block given");
    n = rb_scan_args(argc, argv, "01", &amp;initial_state);
    if (n != 0)
        rb_warn("initial_state given for chunk.  (Use local variables.)");

    enumerator = rb_obj_alloc(rb_cEnumerator);
    rb_ivar_set(enumerator, rb_intern("chunk_enumerable"), enumerable);
    rb_ivar_set(enumerator, rb_intern("chunk_categorize"), rb_block_proc());
    rb_ivar_set(enumerator, rb_intern("chunk_initial_state"), initial_state);
    rb_block_call(enumerator, idInitialize, 0, 0, chunk_i, enumerator);
    return enumerator;
}
            </pre> 
            </div><!-- chunk-source -->
            
          </div>

          

          
        </div><!-- chunk-method -->
      
        <div id="collect-method" class="method-detail ">
          <a name="method-i-collect"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">collect { |obj| block } → array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">collect                 → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new array with the results of running <em>block</em> once for
every element in <em>enum</em>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">4</span>).<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-identifier">i</span> }      <span class="ruby-comment">#=&gt; [1, 4, 9, 16]</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">4</span>).<span class="ruby-identifier">collect</span> { <span class="ruby-string">"cat"</span>  }   <span class="ruby-comment">#=&gt; ["cat", "cat", "cat", "cat"]</span>
</pre>
            

            
            <div class="method-source-code" id="collect-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_collect(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, collect_i, ary);

    return ary;
}
            </pre> 
            </div><!-- collect-source -->
            
          </div>

          

          
        </div><!-- collect-method -->
      
        <div id="collect_concat-method" class="method-detail ">
          <a name="method-i-collect_concat"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">collect_concat { |obj| block } → array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">collect_concat                 → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new array with the concatenated results of running <em>block</em>
once for every element in <em>enum</em>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>].<span class="ruby-identifier">flat_map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">e</span>, <span class="ruby-operator">-</span><span class="ruby-identifier">e</span>] } <span class="ruby-comment">#=&gt; [1, -1, 2, -2, 3, -3, 4, -4]</span>
[[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>], [<span class="ruby-value">3</span>, <span class="ruby-value">4</span>]].<span class="ruby-identifier">flat_map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span> <span class="ruby-operator">+</span> [<span class="ruby-value">100</span>] } <span class="ruby-comment">#=&gt; [1, 2, 100, 3, 4, 100]</span>
</pre>
            

            
            <div class="method-source-code" id="collect_concat-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_flat_map(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, flat_map_i, ary);

    return ary;
}
            </pre> 
            </div><!-- collect_concat-source -->
            
          </div>

          

          
        <div id="collect_concat-method" class="associated_wrapper">
  <div class="associated">
    <h3 class="section-header">Supplemental notes</h3>
<p><code>collect_concat</code> and <code>flat_map</code> are two names for the same method.</p>
  </div>
 </div></div><!-- collect_concat-method -->
      
        <div id="count-method" class="method-detail ">
          <a name="method-i-count"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">count                 → int</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">count(item)           → int</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">count { |obj| block } → int</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the number of items in <code>enum</code> through enumeration. If an
argument is given, the number of items in <code>enum</code> that are equal
to <code>item</code> are counted.  If a block is given, it counts the
number of elements yielding a true value.</p>

<pre class="ruby"><span class="ruby-identifier">ary</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">4</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">ary</span>.<span class="ruby-identifier">count</span>               <span class="ruby-comment">#=&gt; 4</span>
<span class="ruby-identifier">ary</span>.<span class="ruby-identifier">count</span>(<span class="ruby-value">2</span>)            <span class="ruby-comment">#=&gt; 2</span>
<span class="ruby-identifier">ary</span>.<span class="ruby-identifier">count</span>{ <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span><span class="ruby-operator">%</span><span class="ruby-value">2</span><span class="ruby-operator">==</span><span class="ruby-value">0</span> } <span class="ruby-comment">#=&gt; 3</span>
</pre>
            

            
            <div class="method-source-code" id="count-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_count(int argc, VALUE *argv, VALUE obj)
{
    VALUE item = Qnil;
    NODE *memo;
    rb_block_call_func *func;

    if (argc == 0) {
        if (rb_block_given_p()) {
            func = count_iter_i;
        }
        else {
            func = count_all_i;
        }
    }
    else {
        rb_scan_args(argc, argv, "1", &amp;item);
        if (rb_block_given_p()) {
            rb_warn("given block not used");
        }
        func = count_i;
    }

    memo = NEW_MEMO(item, 0, 0);
    rb_block_call(obj, id_each, 0, 0, func, (VALUE)memo);
    return INT2NUM(memo-&gt;u3.cnt);
}
            </pre> 
            </div><!-- count-source -->
            
          </div>

          

          
        </div><!-- count-method -->
      
        <div id="cycle-method" class="method-detail ">
          <a name="method-i-cycle"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">cycle(n=nil) { |obj| block }  →  nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">cycle(n=nil)                  →  an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Calls <em>block</em> for each element of <em>enum</em> repeatedly
<em>n</em> times or forever if none or <code>nil</code> is given.  If a
non-positive number is given or the collection is empty, does nothing. 
Returns <code>nil</code> if the loop has finished without getting
interrupted.</p>

<p><a href="http://ruby-doc.org/core-2.2.0/Enumerable.html#method-i-cycle">#cycle</a> saves elements in an
internal array so changes to <em>enum</em> after the first pass have no
effect.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">"a"</span>, <span class="ruby-string">"b"</span>, <span class="ruby-string">"c"</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">cycle</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">x</span> }  <span class="ruby-comment"># print, a, b, c, a, b, c,.. forever.</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">cycle</span>(<span class="ruby-value">2</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">x</span> }  <span class="ruby-comment"># print, a, b, c, a, b, c.</span>
</pre>
            

            
            <div class="method-source-code" id="cycle-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_cycle(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary;
    VALUE nv = Qnil;
    long n, i, len;

    rb_scan_args(argc, argv, "01", &amp;nv);

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_cycle_size);
    if (NIL_P(nv)) {
        n = -1;
    }
    else {
        n = NUM2LONG(nv);
        if (n &lt;= 0) return Qnil;
    }
    ary = rb_ary_new();
    RBASIC_CLEAR_CLASS(ary);
    rb_block_call(obj, id_each, 0, 0, cycle_i, ary);
    len = RARRAY_LEN(ary);
    if (len == 0) return Qnil;
    while (n &lt; 0 || 0 &lt; --n) {
        for (i=0; i&lt;len; i++) {
            rb_yield(RARRAY_AREF(ary, i));
        }
    }
    return Qnil;
}
            </pre> 
            </div><!-- cycle-source -->
            
          </div>

          

          
        </div><!-- cycle-method -->
      
        <div id="detect-method" class="method-detail ">
          <a name="method-i-detect"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">detect(ifnone = nil) { |obj| block } → obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">detect(ifnone = nil)                 → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Passes each entry in <em>enum</em> to <em>block</em>. Returns the first for
which <em>block</em> is not false.  If no object matches, calls
<em>ifnone</em> and returns its result when it is specified, or returns
<code>nil</code> otherwise.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">detect</span>   { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; nil</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100</span>).<span class="ruby-identifier">find</span>    { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; 35</span>
</pre>
            

            
            <div class="method-source-code" id="detect-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_find(int argc, VALUE *argv, VALUE obj)
{
    NODE *memo;
    VALUE if_none;

    rb_scan_args(argc, argv, "01", &amp;if_none);
    RETURN_ENUMERATOR(obj, argc, argv);
    memo = NEW_MEMO(Qundef, 0, 0);
    rb_block_call(obj, id_each, 0, 0, find_i, (VALUE)memo);
    if (memo-&gt;u3.cnt) {
        return memo-&gt;u1.value;
    }
    if (!NIL_P(if_none)) {
        return rb_funcall(if_none, id_call, 0, 0);
    }
    return Qnil;
}
            </pre> 
            </div><!-- detect-source -->
            
          </div>

          

          
        </div><!-- detect-method -->
      
        <div id="drop-method" class="method-detail ">
          <a name="method-i-drop"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">drop(n)               → array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Drops first n elements from <em>enum</em>, and returns rest elements in an
array.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">drop</span>(<span class="ruby-value">3</span>)             <span class="ruby-comment">#=&gt; [4, 5, 0]</span>
</pre>
            

            
            <div class="method-source-code" id="drop-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_drop(VALUE obj, VALUE n)
{
    VALUE result;
    NODE *memo;
    long len = NUM2LONG(n);

    if (len &lt; 0) {
        rb_raise(rb_eArgError, "attempt to drop negative size");
    }

    result = rb_ary_new();
    memo = NEW_MEMO(result, 0, len);
    rb_block_call(obj, id_each, 0, 0, drop_i, (VALUE)memo);
    return result;
}
            </pre> 
            </div><!-- drop-source -->
            
          </div>

          

          
        </div><!-- drop-method -->
      
        <div id="drop_while-method" class="method-detail ">
          <a name="method-i-drop_while"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">drop_while { |arr| block }  → array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">drop_while                  → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Drops elements up to, but not including, the first element for which the
block returns <code>nil</code> or <code>false</code> and returns an array
containing the remaining elements.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">drop_while</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span> }   <span class="ruby-comment">#=&gt; [3, 4, 5, 0]</span>
</pre>
            

            
            <div class="method-source-code" id="drop_while-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_drop_while(VALUE obj)
{
    VALUE result;
    NODE *memo;

    RETURN_ENUMERATOR(obj, 0, 0);
    result = rb_ary_new();
    memo = NEW_MEMO(result, 0, FALSE);
    rb_block_call(obj, id_each, 0, 0, drop_while_i, (VALUE)memo);
    return result;
}
            </pre> 
            </div><!-- drop_while-source -->
            
          </div>

          

          
        </div><!-- drop_while-method -->
      
        <div id="each_cons-method" class="method-detail ">
          <a name="method-i-each_cons"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_cons(n) { ... } →  nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_cons(n)         →  an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Iterates the given block for each array of consecutive &lt;n&gt; elements. 
If no block is given, returns an enumerator.</p>

<p>e.g.:</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">each_cons</span>(<span class="ruby-value">3</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span> }
<span class="ruby-comment"># outputs below</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]
[<span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>]
[<span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>]
[<span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>]
[<span class="ruby-value">5</span>, <span class="ruby-value">6</span>, <span class="ruby-value">7</span>]
[<span class="ruby-value">6</span>, <span class="ruby-value">7</span>, <span class="ruby-value">8</span>]
[<span class="ruby-value">7</span>, <span class="ruby-value">8</span>, <span class="ruby-value">9</span>]
[<span class="ruby-value">8</span>, <span class="ruby-value">9</span>, <span class="ruby-value">10</span>]
</pre>
            

            
            <div class="method-source-code" id="each_cons-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_each_cons(VALUE obj, VALUE n)
{
    long size = NUM2LONG(n);
    NODE *memo;
    int arity;

    if (size &lt;= 0) rb_raise(rb_eArgError, "invalid size");
    RETURN_SIZED_ENUMERATOR(obj, 1, &amp;n, enum_each_cons_size);
    arity = rb_block_arity();
    memo = NEW_MEMO(rb_ary_new2(size), dont_recycle_block_arg(arity), size);
    rb_block_call(obj, id_each, 0, 0, each_cons_i, (VALUE)memo);

    return Qnil;
}
            </pre> 
            </div><!-- each_cons-source -->
            
          </div>

          

          
        </div><!-- each_cons-method -->
      
        <div id="each_entry-method" class="method-detail ">
          <a name="method-i-each_entry"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_entry { |obj| block }  → enum</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_entry                  → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Calls <em>block</em> once for each element in <code>self</code>, passing
that element as a parameter, converting multiple values from yield to an
array.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Foo</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">Enumerable</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">each</span>
    <span class="ruby-keyword">yield</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">yield</span> <span class="ruby-value">1</span>, <span class="ruby-value">2</span>
    <span class="ruby-keyword">yield</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">Foo</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">each_entry</span>{ <span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">o</span> }
</pre>

<p>produces:</p>

<pre class="ruby"><span class="ruby-value">1</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
<span class="ruby-keyword">nil</span>
</pre>
            

            
            <div class="method-source-code" id="each_entry-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_each_entry(int argc, VALUE *argv, VALUE obj)
{
    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);
    rb_block_call(obj, id_each, argc, argv, each_val_i, 0);
    return obj;
}
            </pre> 
            </div><!-- each_entry-source -->
            
          </div>

          

          
        </div><!-- each_entry-method -->
      
        <div id="each_slice-method" class="method-detail ">
          <a name="method-i-each_slice"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_slice(n) { ... }  →  nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_slice(n)          →  an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Iterates the given block for each slice of &lt;n&gt; elements.  If no block
is given, returns an enumerator.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">each_slice</span>(<span class="ruby-value">3</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span> }
<span class="ruby-comment"># outputs below</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]
[<span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>]
[<span class="ruby-value">7</span>, <span class="ruby-value">8</span>, <span class="ruby-value">9</span>]
[<span class="ruby-value">10</span>]
</pre>
            

            
            <div class="method-source-code" id="each_slice-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_each_slice(VALUE obj, VALUE n)
{
    long size = NUM2LONG(n);
    VALUE ary;
    NODE *memo;
    int arity;

    if (size &lt;= 0) rb_raise(rb_eArgError, "invalid slice size");
    RETURN_SIZED_ENUMERATOR(obj, 1, &amp;n, enum_each_slice_size);
    ary = rb_ary_new2(size);
    arity = rb_block_arity();
    memo = NEW_MEMO(ary, dont_recycle_block_arg(arity), size);
    rb_block_call(obj, id_each, 0, 0, each_slice_i, (VALUE)memo);
    ary = memo-&gt;u1.value;
    if (RARRAY_LEN(ary) &gt; 0) rb_yield(ary);

    return Qnil;
}
            </pre> 
            </div><!-- each_slice-source -->
            
          </div>

          

          
        </div><!-- each_slice-method -->
      
        <div id="each_with_index-method" class="method-detail ">
          <a name="method-i-each_with_index"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_with_index(*args) { |obj, i| block } →  enum</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_with_index(*args)                    →  an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Calls <em>block</em> with two arguments, the item and its index, for each
item in <em>enum</em>.  Given arguments are passed through to each().</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">hash</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>
<span class="ruby-node">%w(cat dog wombat)</span>.<span class="ruby-identifier">each_with_index</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">item</span>, <span class="ruby-identifier">index</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">hash</span>[<span class="ruby-identifier">item</span>] = <span class="ruby-identifier">index</span>
}
<span class="ruby-identifier">hash</span>   <span class="ruby-comment">#=&gt; {"cat"=&gt;0, "dog"=&gt;1, "wombat"=&gt;2}</span>
</pre>
            

            
            <div class="method-source-code" id="each_with_index-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_each_with_index(int argc, VALUE *argv, VALUE obj)
{
    NODE *memo;

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);

    memo = NEW_MEMO(0, 0, 0);
    rb_block_call(obj, id_each, argc, argv, each_with_index_i, (VALUE)memo);
    return obj;
}
            </pre> 
            </div><!-- each_with_index-source -->
            
          </div>

          

          
        </div><!-- each_with_index-method -->
      
        <div id="each_with_object-method" class="method-detail ">
          <a name="method-i-each_with_object"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_with_object(obj) { |(*args), memo_obj| ... }  →  obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_with_object(obj)                              →  an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Iterates the given block for each element with an arbitrary object given,
and returns the initially given object.</p>

<p>If no block is given, returns an enumerator.</p>

<pre class="ruby"><span class="ruby-identifier">evens</span> = (<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">each_with_object</span>([]) { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span>, <span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-value">2</span> }
<span class="ruby-comment">#=&gt; [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]</span>
</pre>
            

            
            <div class="method-source-code" id="each_with_object-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_each_with_object(VALUE obj, VALUE memo)
{
    RETURN_SIZED_ENUMERATOR(obj, 1, &amp;memo, enum_size);

    rb_block_call(obj, id_each, 0, 0, each_with_object_i, memo);

    return memo;
}
            </pre> 
            </div><!-- each_with_object-source -->
            
          </div>

          

          
        </div><!-- each_with_object-method -->
      
        <div id="entries-method" class="method-detail ">
          <a name="method-i-entries"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">entries(*args)   → array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array containing the items in <em>enum</em>.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">7</span>).<span class="ruby-identifier">to_a</span>                       <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5, 6, 7]</span>
{ <span class="ruby-string">'a'</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>, <span class="ruby-string">'b'</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>, <span class="ruby-string">'c'</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">3</span> }.<span class="ruby-identifier">to_a</span>   <span class="ruby-comment">#=&gt; [["a", 1], ["b", 2], ["c", 3]]</span>

<span class="ruby-identifier">require</span> <span class="ruby-string">'prime'</span>
<span class="ruby-constant">Prime</span>.<span class="ruby-identifier">entries</span> <span class="ruby-value">10</span>                  <span class="ruby-comment">#=&gt; [2, 3, 5, 7]</span>
</pre>
            

            
            <div class="method-source-code" id="entries-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_to_a(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary = rb_ary_new();

    rb_block_call(obj, id_each, argc, argv, collect_all, ary);
    OBJ_INFECT(ary, obj);

    return ary;
}
            </pre> 
            </div><!-- entries-source -->
            
          </div>

          

          
        </div><!-- entries-method -->
      
        <div id="find-method" class="method-detail ">
          <a name="method-i-find"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">find(ifnone = nil)   { |obj| block } → obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">find(ifnone = nil)                   → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Passes each entry in <em>enum</em> to <em>block</em>. Returns the first for
which <em>block</em> is not false.  If no object matches, calls
<em>ifnone</em> and returns its result when it is specified, or returns
<code>nil</code> otherwise.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">detect</span>   { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; nil</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100</span>).<span class="ruby-identifier">find</span>    { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; 35</span>
</pre>
            

            
            <div class="method-source-code" id="find-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_find(int argc, VALUE *argv, VALUE obj)
{
    NODE *memo;
    VALUE if_none;

    rb_scan_args(argc, argv, "01", &amp;if_none);
    RETURN_ENUMERATOR(obj, argc, argv);
    memo = NEW_MEMO(Qundef, 0, 0);
    rb_block_call(obj, id_each, 0, 0, find_i, (VALUE)memo);
    if (memo-&gt;u3.cnt) {
        return memo-&gt;u1.value;
    }
    if (!NIL_P(if_none)) {
        return rb_funcall(if_none, id_call, 0, 0);
    }
    return Qnil;
}
            </pre> 
            </div><!-- find-source -->
            
          </div>

          

          
        </div><!-- find-method -->
      
        <div id="find_all-method" class="method-detail ">
          <a name="method-i-find_all"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">find_all { |obj| block } → array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">find_all                 → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array containing all elements of <code>enum</code> for which the
given <code>block</code> returns a true value.</p>

<p>If no block is given, an <a href="http://ruby-doc.org/core-2.2.0/Enumerator.html">Enumerator</a> is
returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">find_all</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">3</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; [3, 6, 9]</span>

[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">4</span>,<span class="ruby-value">5</span>].<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">num</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">num</span>.<span class="ruby-identifier">even?</span>  }   <span class="ruby-comment">#=&gt; [2, 4]</span>
</pre>

<p>See also <a href="http://ruby-doc.org/core-2.2.0/Enumerable.html#method-i-reject">#reject</a>.</p>
            

            
            <div class="method-source-code" id="find_all-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_find_all(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, find_all_i, ary);

    return ary;
}
            </pre> 
            </div><!-- find_all-source -->
            
          </div>

          

          
        </div><!-- find_all-method -->
      
        <div id="find_index-method" class="method-detail ">
          <a name="method-i-find_index"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">find_index(value)          → int or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">find_index { |obj| block } → int or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">find_index                 → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Compares each entry in <em>enum</em> with <em>value</em> or passes to
<em>block</em>.  Returns the index for the first for which the evaluated
value is non-false.  If no object matches, returns <code>nil</code></p>

<p>If neither block nor argument is given, an enumerator is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">find_index</span>  { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }  <span class="ruby-comment">#=&gt; nil</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100</span>).<span class="ruby-identifier">find_index</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }  <span class="ruby-comment">#=&gt; 34</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100</span>).<span class="ruby-identifier">find_index</span>(<span class="ruby-value">50</span>)                                <span class="ruby-comment">#=&gt; 49</span>
</pre>
            

            
            <div class="method-source-code" id="find_index-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_find_index(int argc, VALUE *argv, VALUE obj)
{
    NODE *memo; /* [return value, current index, ] */
    VALUE condition_value = Qnil;
    rb_block_call_func *func;

    if (argc == 0) {
        RETURN_ENUMERATOR(obj, 0, 0);
        func = find_index_iter_i;
    }
    else {
        rb_scan_args(argc, argv, "1", &amp;condition_value);
        if (rb_block_given_p()) {
            rb_warn("given block not used");
        }
        func = find_index_i;
    }

    memo = NEW_MEMO(Qnil, condition_value, 0);
    rb_block_call(obj, id_each, 0, 0, func, (VALUE)memo);
    return memo-&gt;u1.value;
}
            </pre> 
            </div><!-- find_index-source -->
            
          </div>

          

          
        </div><!-- find_index-method -->
      
        <div id="first-method" class="method-detail ">
          <a name="method-i-first"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">first       →  obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">first(n)    →  an_array</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the first element, or the first <code>n</code> elements, of the
enumerable. If the enumerable is empty, the first form returns
<code>nil</code>, and the second form returns an empty array.</p>

<pre class="ruby"><span class="ruby-node">%w[foo bar baz]</span>.<span class="ruby-identifier">first</span>     <span class="ruby-comment">#=&gt; "foo"</span>
<span class="ruby-node">%w[foo bar baz]</span>.<span class="ruby-identifier">first</span>(<span class="ruby-value">2</span>)  <span class="ruby-comment">#=&gt; ["foo", "bar"]</span>
<span class="ruby-node">%w[foo bar baz]</span>.<span class="ruby-identifier">first</span>(<span class="ruby-value">10</span>) <span class="ruby-comment">#=&gt; ["foo", "bar", "baz"]</span>
[].<span class="ruby-identifier">first</span>                  <span class="ruby-comment">#=&gt; nil</span>
</pre>
            

            
            <div class="method-source-code" id="first-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_first(int argc, VALUE *argv, VALUE obj)
{
    NODE *memo;
    rb_check_arity(argc, 0, 1);
    if (argc &gt; 0) {
        return enum_take(obj, argv[0]);
    }
    else {
        memo = NEW_MEMO(Qnil, 0, 0);
        rb_block_call(obj, id_each, 0, 0, first_i, (VALUE)memo);
        return memo-&gt;u1.value;
    }
}
            </pre> 
            </div><!-- first-source -->
            
          </div>

          

          
        </div><!-- first-method -->
      
        <div id="flat_map-method" class="method-detail ">
          <a name="method-i-flat_map"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">flat_map       { |obj| block } → array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">flat_map                       → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new array with the concatenated results of running <em>block</em>
once for every element in <em>enum</em>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>].<span class="ruby-identifier">flat_map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">e</span>, <span class="ruby-operator">-</span><span class="ruby-identifier">e</span>] } <span class="ruby-comment">#=&gt; [1, -1, 2, -2, 3, -3, 4, -4]</span>
[[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>], [<span class="ruby-value">3</span>, <span class="ruby-value">4</span>]].<span class="ruby-identifier">flat_map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span> <span class="ruby-operator">+</span> [<span class="ruby-value">100</span>] } <span class="ruby-comment">#=&gt; [1, 2, 100, 3, 4, 100]</span>
</pre>
            

            
            <div class="method-source-code" id="flat_map-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_flat_map(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, flat_map_i, ary);

    return ary;
}
            </pre> 
            </div><!-- flat_map-source -->
            
          </div>

          

          
        </div><!-- flat_map-method -->
      
        <div id="grep-method" class="method-detail ">
          <a name="method-i-grep"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">grep(pattern)                  → array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">grep(pattern) { |obj| block }  → array</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array of every element in <em>enum</em> for which <code>Pattern
=== element</code>. If the optional <em>block</em> is supplied, each
matching element is passed to it, and the block’s result is stored in the
output array.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100</span>).<span class="ruby-identifier">grep</span> <span class="ruby-value">38</span><span class="ruby-operator">..</span><span class="ruby-value">44</span>   <span class="ruby-comment">#=&gt; [38, 39, 40, 41, 42, 43, 44]</span>
<span class="ruby-identifier">c</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">constants</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">grep</span>(<span class="ruby-regexp">/SEEK/</span>)         <span class="ruby-comment">#=&gt; [:SEEK_SET, :SEEK_CUR, :SEEK_END]</span>
<span class="ruby-identifier">res</span> = <span class="ruby-identifier">c</span>.<span class="ruby-identifier">grep</span>(<span class="ruby-regexp">/SEEK/</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-constant">IO</span>.<span class="ruby-identifier">const_get</span>(<span class="ruby-identifier">v</span>) }
<span class="ruby-identifier">res</span>                    <span class="ruby-comment">#=&gt; [0, 1, 2]</span>
</pre>
            

            
            <div class="method-source-code" id="grep-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_grep(VALUE obj, VALUE pat)
{
    VALUE ary = rb_ary_new();
    NODE *memo = NEW_MEMO(pat, ary, 0);

    rb_block_call(obj, id_each, 0, 0, rb_block_given_p() ? grep_iter_i : grep_i, (VALUE)memo);

    return ary;
}
            </pre> 
            </div><!-- grep-source -->
            
          </div>

          

          
        </div><!-- grep-method -->
      
        <div id="group_by-method" class="method-detail ">
          <a name="method-i-group_by"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">group_by { |obj| block } → a_hash</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">group_by                 → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Groups the collection by result of the block.  Returns a hash where the
keys are the evaluated result from the block and the values are arrays of
elements in the collection that correspond to the key.</p>

<p>If no block is given an enumerator is returned.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">6</span>).<span class="ruby-identifier">group_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">%</span><span class="ruby-value">3</span> }   <span class="ruby-comment">#=&gt; {0=&gt;[3, 6], 1=&gt;[1, 4], 2=&gt;[2, 5]}</span>
</pre>
            

            
            <div class="method-source-code" id="group_by-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_group_by(VALUE obj)
{
    VALUE hash;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    hash = rb_hash_new();
    rb_block_call(obj, id_each, 0, 0, group_by_i, hash);
    OBJ_INFECT(hash, obj);

    return hash;
}
            </pre> 
            </div><!-- group_by-source -->
            
          </div>

          

          
        </div><!-- group_by-method -->
      
        <div id="include-3F-method" class="method-detail ">
          <a name="method-i-include-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">include?(obj)     → true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if any member of <em>enum</em> equals
<em>obj</em>. Equality is tested using <code>==</code>.</p>

<pre class="ruby"><span class="ruby-constant">IO</span>.<span class="ruby-identifier">constants</span>.<span class="ruby-identifier">include?</span> :<span class="ruby-constant">SEEK_SET</span>          <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">constants</span>.<span class="ruby-identifier">include?</span> :<span class="ruby-constant">SEEK_NO_FURTHER</span>   <span class="ruby-comment">#=&gt; false</span>
</pre>
            

            
            <div class="method-source-code" id="include-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_member(VALUE obj, VALUE val)
{
    NODE *memo = NEW_MEMO(val, Qfalse, 0);

    rb_block_call(obj, id_each, 0, 0, member_i, (VALUE)memo);
    return memo-&gt;u2.value;
}
            </pre> 
            </div><!-- include-3F-source -->
            
          </div>

          

          
        </div><!-- include-3F-method -->
      
        <div id="inject-method" class="method-detail ">
          <a name="method-i-inject"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">inject(initial, sym) → obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">inject(sym)          → obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">inject(initial) { |memo, obj| block }  → obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">inject          { |memo, obj| block }  → obj</span>
            
          </div>
          
          
          <div>
  
            
            <p>Combines all elements of <em>enum</em> by applying a binary operation,
specified by a block or a symbol that names a method or operator.</p>

<p>If you specify a block, then for each element in <em>enum</em> the block is
passed an accumulator value (<em>memo</em>) and the element. If you specify
a symbol instead, then each element in the collection will be passed to the
named method of <em>memo</em>. In either case, the result becomes the new
value for <em>memo</em>. At the end of the iteration, the final value of
<em>memo</em> is the return value for the method.</p>

<p>If you do not explicitly specify an <em>initial</em> value for
<em>memo</em>, then the first element of collection is used as the initial
value of <em>memo</em>.</p>

<pre class="ruby"><span class="ruby-comment"># Sum some numbers</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">reduce</span>(:<span class="ruby-operator">+</span>)                             <span class="ruby-comment">#=&gt; 45</span>
<span class="ruby-comment"># Same using a block and inject</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">inject</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">sum</span>, <span class="ruby-identifier">n</span><span class="ruby-operator">|</span> <span class="ruby-identifier">sum</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">n</span> }            <span class="ruby-comment">#=&gt; 45</span>
<span class="ruby-comment"># Multiply some numbers</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">reduce</span>(<span class="ruby-value">1</span>, :<span class="ruby-operator">*</span>)                          <span class="ruby-comment">#=&gt; 151200</span>
<span class="ruby-comment"># Same using a block</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">inject</span>(<span class="ruby-value">1</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">product</span>, <span class="ruby-identifier">n</span><span class="ruby-operator">|</span> <span class="ruby-identifier">product</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">n</span> } <span class="ruby-comment">#=&gt; 151200</span>
<span class="ruby-comment"># find the longest word</span>
<span class="ruby-identifier">longest</span> = <span class="ruby-node">%w{ cat sheep bear }</span>.<span class="ruby-identifier">inject</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">memo</span>, <span class="ruby-identifier">word</span><span class="ruby-operator">|</span>
   <span class="ruby-identifier">memo</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">memo</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">word</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">longest</span>                                        <span class="ruby-comment">#=&gt; "sheep"</span>
</pre>
            

            
            <div class="method-source-code" id="inject-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_inject(int argc, VALUE *argv, VALUE obj)
{
    NODE *memo;
    VALUE init, op;
    rb_block_call_func *iter = inject_i;
    ID id;

    switch (rb_scan_args(argc, argv, "02", &amp;init, &amp;op)) {
      case 0:
        init = Qundef;
        break;
      case 1:
        if (rb_block_given_p()) {
            break;
        }
        id = rb_check_id(&amp;init);
        op = id ? ID2SYM(id) : init;
        init = Qundef;
        iter = inject_op_i;
        break;
      case 2:
        if (rb_block_given_p()) {
            rb_warning("given block not used");
        }
        id = rb_check_id(&amp;op);
        if (id) op = ID2SYM(id);
        iter = inject_op_i;
        break;
    }
    memo = NEW_MEMO(init, Qnil, op);
    rb_block_call(obj, id_each, 0, 0, iter, (VALUE)memo);
    if (memo-&gt;u1.value == Qundef) return Qnil;
    return memo-&gt;u1.value;
}
            </pre> 
            </div><!-- inject-source -->
            
          </div>

          

          
        </div><!-- inject-method -->
      
        <div id="lazy-method" class="method-detail ">
          <a name="method-i-lazy"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">lazy → lazy_enumerator</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a lazy enumerator, whose methods map/collect,
flat_map/collect_concat, select/find_all, reject, grep, zip, take, <a href="http://ruby-doc.org/core-2.2.0/Enumerable.html#method-i-take_while">#take_while</a>, drop, and <a href="http://ruby-doc.org/core-2.2.0/Enumerable.html#method-i-drop_while">#drop_while</a> enumerate values
only on an as-needed basis.  However, if a block is given to zip, values
are enumerated immediately.</p>

<h3 id="method-i-lazy-label-Example">Example<span><a href="#method-i-lazy-label-Example">¶</a> <a href="#top">↑</a></span></h3>

<p>The following program finds pythagorean triples:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">pythagorean_triples</span>
  (<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-constant">Float</span><span class="ruby-operator">::</span><span class="ruby-constant">INFINITY</span>).<span class="ruby-identifier">lazy</span>.<span class="ruby-identifier">flat_map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">z</span><span class="ruby-operator">|</span>
    (<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-identifier">z</span>).<span class="ruby-identifier">flat_map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span>
      (<span class="ruby-identifier">x</span><span class="ruby-operator">..</span><span class="ruby-identifier">z</span>).<span class="ruby-identifier">select</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">y</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">x</span><span class="ruby-operator">**</span><span class="ruby-value">2</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">y</span><span class="ruby-operator">**</span><span class="ruby-value">2</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">z</span><span class="ruby-operator">**</span><span class="ruby-value">2</span>
      }.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">y</span><span class="ruby-operator">|</span>
        [<span class="ruby-identifier">x</span>, <span class="ruby-identifier">y</span>, <span class="ruby-identifier">z</span>]
      }
    }
  }
<span class="ruby-keyword">end</span>
<span class="ruby-comment"># show first ten pythagorean triples</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">pythagorean_triples</span>.<span class="ruby-identifier">take</span>(<span class="ruby-value">10</span>).<span class="ruby-identifier">force</span> <span class="ruby-comment"># take is lazy, so force is needed</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">pythagorean_triples</span>.<span class="ruby-identifier">first</span>(<span class="ruby-value">10</span>)      <span class="ruby-comment"># first is eager</span>
<span class="ruby-comment"># show pythagorean triples less than 100</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">pythagorean_triples</span>.<span class="ruby-identifier">take_while</span> { <span class="ruby-operator">|</span><span class="ruby-operator">*</span>, <span class="ruby-identifier">z</span><span class="ruby-operator">|</span> <span class="ruby-identifier">z</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">100</span> }.<span class="ruby-identifier">force</span>
</pre>
            

            
            <div class="method-source-code" id="lazy-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enumerable_lazy(VALUE obj)
{
    VALUE result = lazy_to_enum_i(obj, sym_each, 0, 0, lazyenum_size);
    /* Qfalse indicates that the Enumerator::Lazy has no method name */
    rb_ivar_set(result, id_method, Qfalse);
    return result;
}
            </pre> 
            </div><!-- lazy-source -->
            
          </div>

          

          
        </div><!-- lazy-method -->
      
        <div id="map-method" class="method-detail ">
          <a name="method-i-map"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">map     { |obj| block } → array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">map                     → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new array with the results of running <em>block</em> once for
every element in <em>enum</em>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">4</span>).<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-identifier">i</span> }      <span class="ruby-comment">#=&gt; [1, 4, 9, 16]</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">4</span>).<span class="ruby-identifier">collect</span> { <span class="ruby-string">"cat"</span>  }   <span class="ruby-comment">#=&gt; ["cat", "cat", "cat", "cat"]</span>
</pre>
            

            
            <div class="method-source-code" id="map-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_collect(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, collect_i, ary);

    return ary;
}
            </pre> 
            </div><!-- map-source -->
            
          </div>

          

          
        </div><!-- map-method -->
      
        <div id="max-method" class="method-detail ">
          <a name="method-i-max"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">max                   → obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">max { |a, b| block }  → obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">max(n)                → obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">max(n) {|a,b| block } → obj</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the object in <em>enum</em> with the maximum value. The first form
assumes all objects implement <code>Comparable</code>; the second uses the
block to return <em>a &lt;=&gt; b</em>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w(albatross dog horse)</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">max</span>                                   <span class="ruby-comment">#=&gt; "horse"</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">max</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">length</span> }  <span class="ruby-comment">#=&gt; "albatross"</span>
</pre>

<p>If the <code>n</code> argument is given, maximum <code>n</code> elements
are returned as an array.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w[albatross dog horse]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">max</span>(<span class="ruby-value">2</span>)                                  <span class="ruby-comment">#=&gt; ["horse", "dog"]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">max</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">length</span> }  <span class="ruby-comment">#=&gt; ["albatross", "horse"]</span>
</pre>
            

            
            <div class="method-source-code" id="max-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_max(int argc, VALUE *argv, VALUE obj)
{
    NODE *memo = NEW_MEMO(Qundef, 0, 0);
    VALUE result;
    VALUE num;

    rb_scan_args(argc, argv, "01", &amp;num);

    if (!NIL_P(num))
       return nmin_run(obj, num, 0, 1);

    if (rb_block_given_p()) {
        rb_block_call(obj, id_each, 0, 0, max_ii, (VALUE)memo);
    }
    else {
        rb_block_call(obj, id_each, 0, 0, max_i, (VALUE)memo);
    }
    result = memo-&gt;u1.value;
    if (result == Qundef) return Qnil;
    return result;
}
            </pre> 
            </div><!-- max-source -->
            
          </div>

          

          
        </div><!-- max-method -->
      
        <div id="max_by-method" class="method-detail ">
          <a name="method-i-max_by"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">max_by {|obj| block }      → obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">max_by                     → an_enumerator</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">max_by(n) {|obj| block }   → obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">max_by(n)                  → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the object in <em>enum</em> that gives the maximum value from the
given block.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w(albatross dog horse)</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">max_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">length</span> }   <span class="ruby-comment">#=&gt; "albatross"</span>
</pre>

<p>If the <code>n</code> argument is given, minimum <code>n</code> elements
are returned as an array.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w[albatross dog horse]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">max_by</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">length</span> } <span class="ruby-comment">#=&gt; ["albatross", "horse"]</span>
</pre>

<p>enum.max_by(n) can be used to implement weighted random sampling. Following
example implements and use Enumerable#wsample.</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">Enumerable</span>
  <span class="ruby-comment"># weighted random sampling.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Pavlos S. Efraimidis, Paul G. Spirakis</span>
  <span class="ruby-comment"># Weighted random sampling with a reservoir</span>
  <span class="ruby-comment"># Information Processing Letters</span>
  <span class="ruby-comment"># Volume 97, Issue 5 (16 March 2006)</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">wsample</span>(<span class="ruby-identifier">n</span>)
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">max_by</span>(<span class="ruby-identifier">n</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">rand</span> <span class="ruby-operator">**</span> (<span class="ruby-value">1.0</span><span class="ruby-operator">/</span><span class="ruby-keyword">yield</span>(<span class="ruby-identifier">v</span>)) }
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">e</span> = (<span class="ruby-value">-20</span><span class="ruby-operator">..</span><span class="ruby-value">20</span>).<span class="ruby-identifier">to_a</span><span class="ruby-operator">*</span><span class="ruby-value">10000</span>
<span class="ruby-identifier">a</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">wsample</span>(<span class="ruby-value">20000</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span>
  <span class="ruby-constant">Math</span>.<span class="ruby-identifier">exp</span>(<span class="ruby-operator">-</span>(<span class="ruby-identifier">x</span><span class="ruby-operator">/</span><span class="ruby-value">5.0</span>)<span class="ruby-operator">**</span><span class="ruby-value">2</span>) <span class="ruby-comment"># normal distribution</span>
}
<span class="ruby-comment"># a is 20000 samples from e.</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">length</span> <span class="ruby-comment">#=&gt; 20000</span>
<span class="ruby-identifier">h</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">group_by</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> }
<span class="ruby-value">-10</span>.<span class="ruby-identifier">upto</span>(<span class="ruby-value">10</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-string">"*"</span> <span class="ruby-operator">*</span> (<span class="ruby-identifier">h</span>[<span class="ruby-identifier">x</span>].<span class="ruby-identifier">length</span><span class="ruby-operator">/</span><span class="ruby-value">30.0</span>).<span class="ruby-identifier">to_i</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">h</span>[<span class="ruby-identifier">x</span>] }
<span class="ruby-comment">#=&gt; *</span>
<span class="ruby-comment">#   ***</span>
<span class="ruby-comment">#   ******</span>
<span class="ruby-comment">#   ***********</span>
<span class="ruby-comment">#   ******************</span>
<span class="ruby-comment">#   *****************************</span>
<span class="ruby-comment">#   *****************************************</span>
<span class="ruby-comment">#   ****************************************************</span>
<span class="ruby-comment">#   ***************************************************************</span>
<span class="ruby-comment">#   ********************************************************************</span>
<span class="ruby-comment">#   ***********************************************************************</span>
<span class="ruby-comment">#   ***********************************************************************</span>
<span class="ruby-comment">#   **************************************************************</span>
<span class="ruby-comment">#   ****************************************************</span>
<span class="ruby-comment">#   ***************************************</span>
<span class="ruby-comment">#   ***************************</span>
<span class="ruby-comment">#   ******************</span>
<span class="ruby-comment">#   ***********</span>
<span class="ruby-comment">#   *******</span>
<span class="ruby-comment">#   ***</span>
<span class="ruby-comment">#   *</span>
</pre>
            

            
            <div class="method-source-code" id="max_by-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_max_by(int argc, VALUE *argv, VALUE obj)
{
    NODE *memo;
    VALUE num;

    rb_scan_args(argc, argv, "01", &amp;num);

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);

    if (!NIL_P(num))
        return nmin_run(obj, num, 1, 1);

    memo = NEW_MEMO(Qundef, Qnil, 0);
    rb_block_call(obj, id_each, 0, 0, max_by_i, (VALUE)memo);
    return memo-&gt;u2.value;
}
            </pre> 
            </div><!-- max_by-source -->
            
          </div>

          

          
        </div><!-- max_by-method -->
      
        <div id="member-3F-method" class="method-detail ">
          <a name="method-i-member-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">member?(obj)      → true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if any member of <em>enum</em> equals
<em>obj</em>. Equality is tested using <code>==</code>.</p>

<pre class="ruby"><span class="ruby-constant">IO</span>.<span class="ruby-identifier">constants</span>.<span class="ruby-identifier">include?</span> :<span class="ruby-constant">SEEK_SET</span>          <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">constants</span>.<span class="ruby-identifier">include?</span> :<span class="ruby-constant">SEEK_NO_FURTHER</span>   <span class="ruby-comment">#=&gt; false</span>
</pre>
            

            
            <div class="method-source-code" id="member-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_member(VALUE obj, VALUE val)
{
    NODE *memo = NEW_MEMO(val, Qfalse, 0);

    rb_block_call(obj, id_each, 0, 0, member_i, (VALUE)memo);
    return memo-&gt;u2.value;
}
            </pre> 
            </div><!-- member-3F-source -->
            
          </div>

          

          
        </div><!-- member-3F-method -->
      
        <div id="min-method" class="method-detail ">
          <a name="method-i-min"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">min                     → obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">min {| a,b | block }    → obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">min(n)                  → array</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">min(n) {| a,b | block } → array</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the object in <em>enum</em> with the minimum value. The first form
assumes all objects implement <code>Comparable</code>; the second uses the
block to return <em>a &lt;=&gt; b</em>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w(albatross dog horse)</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">min</span>                                   <span class="ruby-comment">#=&gt; "albatross"</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">min</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">length</span> }  <span class="ruby-comment">#=&gt; "dog"</span>
</pre>

<p>If the <code>n</code> argument is given, minimum <code>n</code> elements
are returned as an array.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w[albatross dog horse]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">min</span>(<span class="ruby-value">2</span>)                                  <span class="ruby-comment">#=&gt; ["albatross", "dog"]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">min</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">length</span> }  <span class="ruby-comment">#=&gt; ["dog", "horse"]</span>
</pre>
            

            
            <div class="method-source-code" id="min-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_min(int argc, VALUE *argv, VALUE obj)
{
    NODE *memo = NEW_MEMO(Qundef, 0, 0);
    VALUE result;
    VALUE num;

    rb_scan_args(argc, argv, "01", &amp;num);

    if (!NIL_P(num))
       return nmin_run(obj, num, 0, 0);

    if (rb_block_given_p()) {
        rb_block_call(obj, id_each, 0, 0, min_ii, (VALUE)memo);
    }
    else {
        rb_block_call(obj, id_each, 0, 0, min_i, (VALUE)memo);
    }
    result = memo-&gt;u1.value;
    if (result == Qundef) return Qnil;
    return result;
}
            </pre> 
            </div><!-- min-source -->
            
          </div>

          

          
        </div><!-- min-method -->
      
        <div id="min_by-method" class="method-detail ">
          <a name="method-i-min_by"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">min_by {|obj| block }      → obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">min_by                     → an_enumerator</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">min_by(n) {|obj| block }   → array</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">min_by(n)                  → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the object in <em>enum</em> that gives the minimum value from the
given block.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w(albatross dog horse)</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">min_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">length</span> }   <span class="ruby-comment">#=&gt; "dog"</span>
</pre>

<p>If the <code>n</code> argument is given, minimum <code>n</code> elements
are returned as an array.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w[albatross dog horse]</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">min_by</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">length</span> } <span class="ruby-comment">#=&gt; ["dog", "horse"]</span>
</pre>
            

            
            <div class="method-source-code" id="min_by-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_min_by(int argc, VALUE *argv, VALUE obj)
{
    NODE *memo;
    VALUE num;

    rb_scan_args(argc, argv, "01", &amp;num);

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);

    if (!NIL_P(num))
        return nmin_run(obj, num, 1, 0);

    memo = NEW_MEMO(Qundef, Qnil, 0);
    rb_block_call(obj, id_each, 0, 0, min_by_i, (VALUE)memo);
    return memo-&gt;u2.value;
}
            </pre> 
            </div><!-- min_by-source -->
            
          </div>

          

          
        </div><!-- min_by-method -->
      
        <div id="minmax-method" class="method-detail ">
          <a name="method-i-minmax"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">minmax                  → [min, max]</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">minmax { |a, b| block } → [min, max]</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns two elements array which contains the minimum and the maximum value
in the enumerable.  The first form assumes all objects implement
<code>Comparable</code>; the second uses the block to return <em>a
&lt;=&gt; b</em>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w(albatross dog horse)</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">minmax</span>                                  <span class="ruby-comment">#=&gt; ["albatross", "horse"]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">minmax</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">length</span> } <span class="ruby-comment">#=&gt; ["dog", "albatross"]</span>
</pre>
            

            
            <div class="method-source-code" id="minmax-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_minmax(VALUE obj)
{
    NODE *memo = NEW_MEMO(Qundef, Qundef, Qundef);
    struct minmax_t *m = (struct minmax_t *)&amp;memo-&gt;u1.value;
    VALUE ary = rb_ary_new3(2, Qnil, Qnil);

    m-&gt;min = Qundef;
    m-&gt;last = Qundef;
    if (rb_block_given_p()) {
        rb_block_call(obj, id_each, 0, 0, minmax_ii, (VALUE)memo);
        if (m-&gt;last != Qundef)
            minmax_ii_update(m-&gt;last, m-&gt;last, m);
    }
    else {
        rb_block_call(obj, id_each, 0, 0, minmax_i, (VALUE)memo);
        if (m-&gt;last != Qundef)
            minmax_i_update(m-&gt;last, m-&gt;last, m);
    }
    if (m-&gt;min != Qundef) {
        rb_ary_store(ary, 0, m-&gt;min);
        rb_ary_store(ary, 1, m-&gt;max);
    }
    return ary;
}
            </pre> 
            </div><!-- minmax-source -->
            
          </div>

          

          
        </div><!-- minmax-method -->
      
        <div id="minmax_by-method" class="method-detail ">
          <a name="method-i-minmax_by"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">minmax_by { |obj| block } → [min, max]</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">minmax_by                 → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a two element array containing the objects in <em>enum</em> that
correspond to the minimum and maximum values respectively from the given
block.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w(albatross dog horse)</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">minmax_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">length</span> }   <span class="ruby-comment">#=&gt; ["dog", "albatross"]</span>
</pre>
            

            
            <div class="method-source-code" id="minmax_by-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_minmax_by(VALUE obj)
{
    VALUE memo;
    struct minmax_by_t *m = NEW_MEMO_FOR(struct minmax_by_t, memo);

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    m-&gt;min_bv = Qundef;
    m-&gt;max_bv = Qundef;
    m-&gt;min = Qnil;
    m-&gt;max = Qnil;
    m-&gt;last_bv = Qundef;
    m-&gt;last = Qundef;
    rb_block_call(obj, id_each, 0, 0, minmax_by_i, memo);
    if (m-&gt;last_bv != Qundef)
        minmax_by_i_update(m-&gt;last_bv, m-&gt;last_bv, m-&gt;last, m-&gt;last, m);
    m = MEMO_FOR(struct minmax_by_t, memo);
    return rb_assoc_new(m-&gt;min, m-&gt;max);
}
            </pre> 
            </div><!-- minmax_by-source -->
            
          </div>

          

          
        </div><!-- minmax_by-method -->
      
        <div id="none-3F-method" class="method-detail ">
          <a name="method-i-none-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">none? [{ |obj| block }]   → true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Passes each element of the collection to the given block. The method
returns <code>true</code> if the block never returns <code>true</code> for
all elements. If the block is not given, <code>none?</code> will return
<code>true</code> only if none of the collection members is true.</p>

<pre class="ruby"><span class="ruby-node">%w{ant bear cat}</span>.<span class="ruby-identifier">none?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">5</span> } <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-node">%w{ant bear cat}</span>.<span class="ruby-identifier">none?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">4</span> } <span class="ruby-comment">#=&gt; false</span>
[].<span class="ruby-identifier">none?</span>                                           <span class="ruby-comment">#=&gt; true</span>
[<span class="ruby-keyword">nil</span>].<span class="ruby-identifier">none?</span>                                        <span class="ruby-comment">#=&gt; true</span>
[<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">false</span>].<span class="ruby-identifier">none?</span>                                 <span class="ruby-comment">#=&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="none-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_none(VALUE obj)
{
    NODE *memo = NEW_MEMO(Qtrue, 0, 0);
    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(none), (VALUE)memo);
    return memo-&gt;u1.value;
}
            </pre> 
            </div><!-- none-3F-source -->
            
          </div>

          

          
        </div><!-- none-3F-method -->
      
        <div id="one-3F-method" class="method-detail ">
          <a name="method-i-one-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">one? [{ |obj| block }]   → true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Passes each element of the collection to the given block. The method
returns <code>true</code> if the block returns <code>true</code> exactly
once. If the block is not given, <code>one?</code> will return
<code>true</code> only if exactly one of the collection members is true.</p>

<pre class="ruby"><span class="ruby-node">%w{ant bear cat}</span>.<span class="ruby-identifier">one?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">4</span> }  <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-node">%w{ant bear cat}</span>.<span class="ruby-identifier">one?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">4</span> }   <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-node">%w{ant bear cat}</span>.<span class="ruby-identifier">one?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">4</span> }   <span class="ruby-comment">#=&gt; false</span>
[ <span class="ruby-keyword">nil</span>, <span class="ruby-keyword">true</span>, <span class="ruby-value">99</span> ].<span class="ruby-identifier">one?</span>                             <span class="ruby-comment">#=&gt; false</span>
[ <span class="ruby-keyword">nil</span>, <span class="ruby-keyword">true</span>, <span class="ruby-keyword">false</span> ].<span class="ruby-identifier">one?</span>                          <span class="ruby-comment">#=&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="one-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_one(VALUE obj)
{
    NODE *memo = NEW_MEMO(Qundef, 0, 0);
    VALUE result;

    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(one), (VALUE)memo);
    result = memo-&gt;u1.value;
    if (result == Qundef) return Qfalse;
    return result;
}
            </pre> 
            </div><!-- one-3F-source -->
            
          </div>

          

          
        </div><!-- one-3F-method -->
      
        <div id="partition-method" class="method-detail ">
          <a name="method-i-partition"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">partition { |obj| block } → [ true_array, false_array ]</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">partition                 → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns two arrays, the first containing the elements of <em>enum</em> for
which the block evaluates to true, the second containing the rest.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">6</span>).<span class="ruby-identifier">partition</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">even?</span> }  <span class="ruby-comment">#=&gt; [[2, 4, 6], [1, 3, 5]]</span>
</pre>
            

            
            <div class="method-source-code" id="partition-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_partition(VALUE obj)
{
    NODE *memo;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    memo = NEW_MEMO(rb_ary_new(), rb_ary_new(), 0);
    rb_block_call(obj, id_each, 0, 0, partition_i, (VALUE)memo);

    return rb_assoc_new(memo-&gt;u1.value, memo-&gt;u2.value);
}
            </pre> 
            </div><!-- partition-source -->
            
          </div>

          

          
        </div><!-- partition-method -->
      
        <div id="reduce-method" class="method-detail ">
          <a name="method-i-reduce"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reduce(initial, sym) → obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reduce(sym)          → obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reduce(initial) { |memo, obj| block }  → obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reduce          { |memo, obj| block }  → obj</span>
            
          </div>
          
          
          <div>
  
            
            <p>Combines all elements of <em>enum</em> by applying a binary operation,
specified by a block or a symbol that names a method or operator.</p>

<p>If you specify a block, then for each element in <em>enum</em> the block is
passed an accumulator value (<em>memo</em>) and the element. If you specify
a symbol instead, then each element in the collection will be passed to the
named method of <em>memo</em>. In either case, the result becomes the new
value for <em>memo</em>. At the end of the iteration, the final value of
<em>memo</em> is the return value for the method.</p>

<p>If you do not explicitly specify an <em>initial</em> value for
<em>memo</em>, then the first element of collection is used as the initial
value of <em>memo</em>.</p>

<pre class="ruby"><span class="ruby-comment"># Sum some numbers</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">reduce</span>(:<span class="ruby-operator">+</span>)                             <span class="ruby-comment">#=&gt; 45</span>
<span class="ruby-comment"># Same using a block and inject</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">inject</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">sum</span>, <span class="ruby-identifier">n</span><span class="ruby-operator">|</span> <span class="ruby-identifier">sum</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">n</span> }            <span class="ruby-comment">#=&gt; 45</span>
<span class="ruby-comment"># Multiply some numbers</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">reduce</span>(<span class="ruby-value">1</span>, :<span class="ruby-operator">*</span>)                          <span class="ruby-comment">#=&gt; 151200</span>
<span class="ruby-comment"># Same using a block</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">inject</span>(<span class="ruby-value">1</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">product</span>, <span class="ruby-identifier">n</span><span class="ruby-operator">|</span> <span class="ruby-identifier">product</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">n</span> } <span class="ruby-comment">#=&gt; 151200</span>
<span class="ruby-comment"># find the longest word</span>
<span class="ruby-identifier">longest</span> = <span class="ruby-node">%w{ cat sheep bear }</span>.<span class="ruby-identifier">inject</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">memo</span>, <span class="ruby-identifier">word</span><span class="ruby-operator">|</span>
   <span class="ruby-identifier">memo</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">memo</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">word</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">longest</span>                                        <span class="ruby-comment">#=&gt; "sheep"</span>
</pre>
            

            
            <div class="method-source-code" id="reduce-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_inject(int argc, VALUE *argv, VALUE obj)
{
    NODE *memo;
    VALUE init, op;
    rb_block_call_func *iter = inject_i;
    ID id;

    switch (rb_scan_args(argc, argv, "02", &amp;init, &amp;op)) {
      case 0:
        init = Qundef;
        break;
      case 1:
        if (rb_block_given_p()) {
            break;
        }
        id = rb_check_id(&amp;init);
        op = id ? ID2SYM(id) : init;
        init = Qundef;
        iter = inject_op_i;
        break;
      case 2:
        if (rb_block_given_p()) {
            rb_warning("given block not used");
        }
        id = rb_check_id(&amp;op);
        if (id) op = ID2SYM(id);
        iter = inject_op_i;
        break;
    }
    memo = NEW_MEMO(init, Qnil, op);
    rb_block_call(obj, id_each, 0, 0, iter, (VALUE)memo);
    if (memo-&gt;u1.value == Qundef) return Qnil;
    return memo-&gt;u1.value;
}
            </pre> 
            </div><!-- reduce-source -->
            
          </div>

          

          
        </div><!-- reduce-method -->
      
        <div id="reject-method" class="method-detail ">
          <a name="method-i-reject"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reject { |obj| block } → array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reject                 → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array for all elements of <code>enum</code> for which the given
<code>block</code> returns false.</p>

<p>If no block is given, an <a href="http://ruby-doc.org/core-2.2.0/Enumerator.html">Enumerator</a> is
returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">reject</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">3</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; [1, 2, 4, 5, 7, 8, 10]</span>

[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>].<span class="ruby-identifier">reject</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">num</span><span class="ruby-operator">|</span> <span class="ruby-identifier">num</span>.<span class="ruby-identifier">even?</span> } <span class="ruby-comment">#=&gt; [1, 3, 5]</span>
</pre>

<p>See also <a href="http://ruby-doc.org/core-2.2.0/Enumerable.html#method-i-find_all">#find_all</a>.</p>
            

            
            <div class="method-source-code" id="reject-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_reject(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, reject_i, ary);

    return ary;
}
            </pre> 
            </div><!-- reject-source -->
            
          </div>

          

          
        </div><!-- reject-method -->
      
        <div id="reverse_each-method" class="method-detail ">
          <a name="method-i-reverse_each"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reverse_each(*args) { |item| block } →  enum</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reverse_each(*args)                  →  an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Builds a temporary array and traverses that array in reverse order.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>  (1..3).reverse_each { |v| p v }

produces:

  3
  2
  1</pre>
            

            
            <div class="method-source-code" id="reverse_each-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_reverse_each(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary;
    long i;

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);

    ary = enum_to_a(argc, argv, obj);

    for (i = RARRAY_LEN(ary); --i &gt;= 0; ) {
        rb_yield(RARRAY_AREF(ary, i));
    }

    return obj;
}
            </pre> 
            </div><!-- reverse_each-source -->
            
          </div>

          

          
        </div><!-- reverse_each-method -->
      
        <div id="select-method" class="method-detail ">
          <a name="method-i-select"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">select   { |obj| block } → array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">select                   → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array containing all elements of <code>enum</code> for which the
given <code>block</code> returns a true value.</p>

<p>If no block is given, an <a href="http://ruby-doc.org/core-2.2.0/Enumerator.html">Enumerator</a> is
returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">find_all</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">3</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; [3, 6, 9]</span>

[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">4</span>,<span class="ruby-value">5</span>].<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">num</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">num</span>.<span class="ruby-identifier">even?</span>  }   <span class="ruby-comment">#=&gt; [2, 4]</span>
</pre>

<p>See also <a href="http://ruby-doc.org/core-2.2.0/Enumerable.html#method-i-reject">#reject</a>.</p>
            

            
            <div class="method-source-code" id="select-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_find_all(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, find_all_i, ary);

    return ary;
}
            </pre> 
            </div><!-- select-source -->
            
          </div>

          

          
        <div id="select-method" class="associated_wrapper">
  <div class="associated">
    <h3 class="section-header">Supplemental notes</h3>
<p>When used with a Hash instance <code>select</code> returns another Hash object</p>

<p>  {:a =&gt; 1, :b =&gt; 2}.select{ |k,v| v == 1 } #=&gt; {:a =&gt; 1 }</p>
  </div>
 </div></div><!-- select-method -->
      
        <div id="slice_after-method" class="method-detail ">
          <a name="method-i-slice_after"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">slice_after(pattern)       → an_enumerator</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice_after { |elt| bool } → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates an enumerator for each chunked elements. The ends of chunks are
defined by <em>pattern</em> and the block.</p>

<p>If <code><em>pattern</em> === <em>elt</em></code> returns <code>true</code>
or the block returns <code>true</code> for the element, the element is end
of a chunk.</p>

<p>The <code>===</code> and <em>block</em> is called from the first element to
the last element of <em>enum</em>.</p>

<p>The result enumerator yields the chunked elements as an array. So
<code>each</code> method can be called as follows:</p>

<pre>enum.slice_after(pattern).each { |ary| ... }
enum.slice_after { |elt| bool }.each { |ary| ... }</pre>

<p>Other methods of the <a href="http://ruby-doc.org/core-2.2.0/Enumerator.html">Enumerator</a> class and <a href="http://ruby-doc.org/core-2.2.0/Enumerable.html">Enumerable</a> module, such as <code>map</code>,
etc., are also usable.</p>

<p>For example, continuation lines (lines end with backslash) can be
concatenated as follows:</p>

<pre class="ruby"><span class="ruby-identifier">lines</span> = [<span class="ruby-string">"foo\n"</span>, <span class="ruby-string">"bar\\\n"</span>, <span class="ruby-string">"baz\n"</span>, <span class="ruby-string">"\n"</span>, <span class="ruby-string">"qux\n"</span>]
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">slice_after</span>(<span class="ruby-regexp">/(?&lt;!\)\n\z/</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_a</span>
<span class="ruby-comment">#=&gt; [["foo\n"], ["bar\\\n", "baz\n"], ["\n"], ["qux\n"]]</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">ll</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ll</span>[<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-value">-1</span>].<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">l</span><span class="ruby-operator">|</span> <span class="ruby-identifier">l</span>.<span class="ruby-identifier">sub</span>(<span class="ruby-regexp">/\\n\z/</span>, <span class="ruby-string">""</span>) }.<span class="ruby-identifier">join</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">ll</span>.<span class="ruby-identifier">last</span> }
<span class="ruby-comment">#=&gt;["foo\n", "barbaz\n", "\n", "qux\n"]</span>
</pre>
            

            
            <div class="method-source-code" id="slice_after-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_slice_after(int argc, VALUE *argv, VALUE enumerable)
{
    VALUE enumerator;
    VALUE pat = Qnil, pred = Qnil;

    if (rb_block_given_p()) {
        if (0 &lt; argc)
            rb_raise(rb_eArgError, "both pattan and block are given");
        pred = rb_block_proc();
    }
    else {
        rb_scan_args(argc, argv, "1", &amp;pat);
    }

    enumerator = rb_obj_alloc(rb_cEnumerator);
    rb_ivar_set(enumerator, rb_intern("sliceafter_enum"), enumerable);
    rb_ivar_set(enumerator, rb_intern("sliceafter_pat"), pat);
    rb_ivar_set(enumerator, rb_intern("sliceafter_pred"), pred);

    rb_block_call(enumerator, idInitialize, 0, 0, sliceafter_i, enumerator);
    return enumerator;
}
            </pre> 
            </div><!-- slice_after-source -->
            
          </div>

          

          
        </div><!-- slice_after-method -->
      
        <div id="slice_before-method" class="method-detail ">
          <a name="method-i-slice_before"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">slice_before(pattern)                             → an_enumerator</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice_before { |elt| bool }                       → an_enumerator</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice_before(initial_state) { |elt, state| bool } → an_enumerator (deprecated)</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates an enumerator for each chunked elements. The beginnings of chunks
are defined by <em>pattern</em> and the block.</p>

<p>If <code><em>pattern</em> === <em>elt</em></code> returns <code>true</code>
or the block returns <code>true</code> for the element, the element is
beginning of a chunk.</p>

<p>The <code>===</code> and <em>block</em> is called from the first element to
the last element of <em>enum</em>.  The result for the first element is
ignored.</p>

<p>The result enumerator yields the chunked elements as an array. So
<code>each</code> method can be called as follows:</p>

<pre>enum.slice_before(pattern).each { |ary| ... }
enum.slice_before { |elt| bool }.each { |ary| ... }</pre>

<p>Other methods of the <a href="http://ruby-doc.org/core-2.2.0/Enumerator.html">Enumerator</a> class and <a href="http://ruby-doc.org/core-2.2.0/Enumerable.html">Enumerable</a> module, such as map, etc., are also
usable.</p>

<p>For example, iteration over ChangeLog entries can be implemented as
follows:</p>

<pre class="ruby"><span class="ruby-comment"># iterate over ChangeLog entries.</span>
<span class="ruby-identifier">open</span>(<span class="ruby-string">"ChangeLog"</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">slice_before</span>(<span class="ruby-regexp">/\A\S/</span>).<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">pp</span> <span class="ruby-identifier">e</span> }
}

<span class="ruby-comment"># same as above.  block is used instead of pattern argument.</span>
<span class="ruby-identifier">open</span>(<span class="ruby-string">"ChangeLog"</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">slice_before</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span> <span class="ruby-regexp">/\A\S/</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">line</span> }.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">pp</span> <span class="ruby-identifier">e</span> }
}
</pre>

<p>“svn proplist -R” produces multiline output for each file. They can be
chunked as follows:</p>

<pre class="ruby"><span class="ruby-constant">IO</span>.<span class="ruby-identifier">popen</span>([{<span class="ruby-string">"LC_ALL"</span>=<span class="ruby-operator">&gt;</span><span class="ruby-string">"C"</span>}, <span class="ruby-string">"svn"</span>, <span class="ruby-string">"proplist"</span>, <span class="ruby-string">"-R"</span>]) { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">lines</span>.<span class="ruby-identifier">slice_before</span>(<span class="ruby-regexp">/\AProp/</span>).<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">lines</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">lines</span> }
}
<span class="ruby-comment">#=&gt; ["Properties on '.':\n", "  svn:ignore\n", "  svk:merge\n"]</span>
<span class="ruby-comment">#   ["Properties on 'goruby.c':\n", "  svn:eol-style\n"]</span>
<span class="ruby-comment">#   ["Properties on 'complex.c':\n", "  svn:mime-type\n", "  svn:eol-style\n"]</span>
<span class="ruby-comment">#   ["Properties on 'regparse.c':\n", "  svn:eol-style\n"]</span>
<span class="ruby-comment">#   ...</span>
</pre>

<p>If the block needs to maintain state over multiple elements, local
variables can be used. For example, three or more consecutive increasing
numbers can be squashed as follows:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">6</span>, <span class="ruby-value">7</span>, <span class="ruby-value">9</span>]
<span class="ruby-identifier">prev</span> = <span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>]
<span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice_before</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">prev</span>, <span class="ruby-identifier">prev2</span> = <span class="ruby-identifier">e</span>, <span class="ruby-identifier">prev</span>
  <span class="ruby-identifier">prev2</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">e</span>
}.<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">es</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">es</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-value">2</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">es</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">","</span>) <span class="ruby-operator">:</span> <span class="ruby-node">"#{es.first}-#{es.last}"</span>
}.<span class="ruby-identifier">join</span>(<span class="ruby-string">","</span>)
<span class="ruby-comment">#=&gt; "0,2-4,6,7,9"</span>
</pre>

<p>However local variables should be used carefully if the result enumerator
is enumerated twice or more. The local variables should be initialized for
each enumeration. <a href="http://ruby-doc.org/core-2.2.0/Enumerator.html#method-c-new">Enumerator.new</a>
can be used to do it.</p>

<pre class="ruby"><span class="ruby-comment"># Word wrapping.  This assumes all characters have same width.</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">wordwrap</span>(<span class="ruby-identifier">words</span>, <span class="ruby-identifier">maxwidth</span>)
  <span class="ruby-constant">Enumerator</span>.<span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">y</span><span class="ruby-operator">|</span>
    <span class="ruby-comment"># cols is initialized in Enumerator.new.</span>
    <span class="ruby-identifier">cols</span> = <span class="ruby-value">0</span>
    <span class="ruby-identifier">words</span>.<span class="ruby-identifier">slice_before</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">w</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">cols</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">cols</span> <span class="ruby-operator">!=</span> <span class="ruby-value">0</span>
      <span class="ruby-identifier">cols</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">w</span>.<span class="ruby-identifier">length</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">maxwidth</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">cols</span>
        <span class="ruby-identifier">cols</span> = <span class="ruby-identifier">w</span>.<span class="ruby-identifier">length</span>
        <span class="ruby-keyword">true</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-keyword">false</span>
      <span class="ruby-keyword">end</span>
    }.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">ws</span><span class="ruby-operator">|</span> <span class="ruby-identifier">y</span>.<span class="ruby-identifier">yield</span> <span class="ruby-identifier">ws</span> }
  }
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">text</span> = (<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">20</span>).<span class="ruby-identifier">to_a</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">" "</span>)
<span class="ruby-identifier">enum</span> = <span class="ruby-identifier">wordwrap</span>(<span class="ruby-identifier">text</span>.<span class="ruby-identifier">split</span>(<span class="ruby-regexp">/\s+/</span>), <span class="ruby-value">10</span>)
<span class="ruby-identifier">puts</span> <span class="ruby-string">"-"</span><span class="ruby-operator">*</span><span class="ruby-value">10</span>
<span class="ruby-identifier">enum</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">ws</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">ws</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">" "</span>) } <span class="ruby-comment"># first enumeration.</span>
<span class="ruby-identifier">puts</span> <span class="ruby-string">"-"</span><span class="ruby-operator">*</span><span class="ruby-value">10</span>
<span class="ruby-identifier">enum</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">ws</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">ws</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">" "</span>) } <span class="ruby-comment"># second enumeration generates same result as the first.</span>
<span class="ruby-identifier">puts</span> <span class="ruby-string">"-"</span><span class="ruby-operator">*</span><span class="ruby-value">10</span>
<span class="ruby-comment">#=&gt; ----------</span>
<span class="ruby-comment">#   1 2 3 4 5</span>
<span class="ruby-comment">#   6 7 8 9 10</span>
<span class="ruby-comment">#   11 12 13</span>
<span class="ruby-comment">#   14 15 16</span>
<span class="ruby-comment">#   17 18 19</span>
<span class="ruby-comment">#   20</span>
<span class="ruby-comment">#   ----------</span>
<span class="ruby-comment">#   1 2 3 4 5</span>
<span class="ruby-comment">#   6 7 8 9 10</span>
<span class="ruby-comment">#   11 12 13</span>
<span class="ruby-comment">#   14 15 16</span>
<span class="ruby-comment">#   17 18 19</span>
<span class="ruby-comment">#   20</span>
<span class="ruby-comment">#   ----------</span>
</pre>

<p>mbox contains series of mails which start with Unix From line. So each mail
can be extracted by slice before Unix From line.</p>

<pre class="ruby"><span class="ruby-comment"># parse mbox</span>
<span class="ruby-identifier">open</span>(<span class="ruby-string">"mbox"</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">slice_before</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">line</span>.<span class="ruby-identifier">start_with?</span> <span class="ruby-string">"From "</span>
  }.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">mail</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">unix_from</span> = <span class="ruby-identifier">mail</span>.<span class="ruby-identifier">shift</span>
    <span class="ruby-identifier">i</span> = <span class="ruby-identifier">mail</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">"\n"</span>)
    <span class="ruby-identifier">header</span> = <span class="ruby-identifier">mail</span>[<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">i</span>]
    <span class="ruby-identifier">body</span> = <span class="ruby-identifier">mail</span>[(<span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>)<span class="ruby-operator">..</span><span class="ruby-value">-1</span>]
    <span class="ruby-identifier">body</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">body</span>.<span class="ruby-identifier">last</span> <span class="ruby-operator">==</span> <span class="ruby-string">"\n"</span>
    <span class="ruby-identifier">fields</span> = <span class="ruby-identifier">header</span>.<span class="ruby-identifier">slice_before</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span> <span class="ruby-operator">!</span><span class="ruby-string">" \t"</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">line</span>[<span class="ruby-value">0</span>]) }.<span class="ruby-identifier">to_a</span>
    <span class="ruby-identifier">p</span> <span class="ruby-identifier">unix_from</span>
    <span class="ruby-identifier">pp</span> <span class="ruby-identifier">fields</span>
    <span class="ruby-identifier">pp</span> <span class="ruby-identifier">body</span>
  }
}

<span class="ruby-comment"># split mails in mbox (slice before Unix From line after an empty line)</span>
<span class="ruby-identifier">open</span>(<span class="ruby-string">"mbox"</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">slice_before</span>(<span class="ruby-identifier">emp</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">line</span>, <span class="ruby-identifier">h</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">prevemp</span> = <span class="ruby-identifier">h</span>[:<span class="ruby-identifier">emp</span>]
    <span class="ruby-identifier">h</span>[:<span class="ruby-identifier">emp</span>] = <span class="ruby-identifier">line</span> <span class="ruby-operator">==</span> <span class="ruby-string">"\n"</span>
    <span class="ruby-identifier">prevemp</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">"From "</span>)
  }.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">mail</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">mail</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">mail</span>.<span class="ruby-identifier">last</span> <span class="ruby-operator">==</span> <span class="ruby-string">"\n"</span>
    <span class="ruby-identifier">pp</span> <span class="ruby-identifier">mail</span>
  }
}
</pre>
            

            
            <div class="method-source-code" id="slice_before-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_slice_before(int argc, VALUE *argv, VALUE enumerable)
{
    VALUE enumerator;

    if (rb_block_given_p()) {
        VALUE initial_state;
        int n;
        n = rb_scan_args(argc, argv, "01", &amp;initial_state);
        if (n != 0)
            rb_warn("initial_state given for slice_before.  (Use local variables.)");
        enumerator = rb_obj_alloc(rb_cEnumerator);
        rb_ivar_set(enumerator, rb_intern("slicebefore_sep_pred"), rb_block_proc());
        rb_ivar_set(enumerator, rb_intern("slicebefore_initial_state"), initial_state);
    }
    else {
        VALUE sep_pat;
        rb_scan_args(argc, argv, "1", &amp;sep_pat);
        enumerator = rb_obj_alloc(rb_cEnumerator);
        rb_ivar_set(enumerator, rb_intern("slicebefore_sep_pat"), sep_pat);
    }
    rb_ivar_set(enumerator, rb_intern("slicebefore_enumerable"), enumerable);
    rb_block_call(enumerator, idInitialize, 0, 0, slicebefore_i, enumerator);
    return enumerator;
}
            </pre> 
            </div><!-- slice_before-source -->
            
          </div>

          

          
        </div><!-- slice_before-method -->
      
        <div id="slice_when-method" class="method-detail ">
          <a name="method-i-slice_when"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">slice_when {|elt_before, elt_after| bool } → an_enumerator</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates an enumerator for each chunked elements. The beginnings of chunks
are defined by the block.</p>

<p>This method split each chunk using adjacent elements, <em>elt_before</em>
and <em>elt_after</em>, in the receiver enumerator. This method split
chunks between <em>elt_before</em> and <em>elt_after</em> where the block
returns true.</p>

<p>The block is called the length of the receiver enumerator minus one.</p>

<p>The result enumerator yields the chunked elements as an array. So
<code>each</code> method can be called as follows:</p>

<pre>enum.slice_when { |elt_before, elt_after| bool }.each { |ary| ... }</pre>

<p>Other methods of the <a href="http://ruby-doc.org/core-2.2.0/Enumerator.html">Enumerator</a> class and <a href="http://ruby-doc.org/core-2.2.0/Enumerable.html">Enumerable</a> module, such as <code>to_a</code>,
<code>map</code>, etc., are also usable.</p>

<p>For example, one-by-one increasing subsequence can be chunked as follows:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">4</span>,<span class="ruby-value">9</span>,<span class="ruby-value">10</span>,<span class="ruby-value">11</span>,<span class="ruby-value">12</span>,<span class="ruby-value">15</span>,<span class="ruby-value">16</span>,<span class="ruby-value">19</span>,<span class="ruby-value">20</span>,<span class="ruby-value">21</span>]
<span class="ruby-identifier">b</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice_when</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span>, <span class="ruby-identifier">j</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-value">1</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">j</span> }
<span class="ruby-identifier">p</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">to_a</span> <span class="ruby-comment">#=&gt; [[1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21]]</span>
<span class="ruby-identifier">c</span> = <span class="ruby-identifier">b</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">:</span> <span class="ruby-node">"#{a.first}-#{a.last}"</span> }
<span class="ruby-identifier">p</span> <span class="ruby-identifier">c</span> <span class="ruby-comment">#=&gt; [[1, 2], [4], "9-12", [15, 16], "19-21"]</span>
<span class="ruby-identifier">d</span> = <span class="ruby-identifier">c</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">","</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">d</span> <span class="ruby-comment">#=&gt; "1,2,4,9-12,15,16,19-21"</span>
</pre>

<p>Near elements (threshold: 6) in sorted array can be chunked as follwos:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">3</span>, <span class="ruby-value">11</span>, <span class="ruby-value">14</span>, <span class="ruby-value">25</span>, <span class="ruby-value">28</span>, <span class="ruby-value">29</span>, <span class="ruby-value">29</span>, <span class="ruby-value">41</span>, <span class="ruby-value">55</span>, <span class="ruby-value">57</span>]
<span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice_when</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span>, <span class="ruby-identifier">j</span><span class="ruby-operator">|</span> <span class="ruby-value">6</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">j</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">i</span> }.<span class="ruby-identifier">to_a</span>
<span class="ruby-comment">#=&gt; [[3], [11, 14], [25, 28, 29, 29], [41], [55, 57]]</span>
</pre>

<p>Increasing (non-decreasing) subsequence can be chunked as follows:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">9</span>, <span class="ruby-value">2</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">2</span>, <span class="ruby-value">7</span>, <span class="ruby-value">5</span>, <span class="ruby-value">9</span>, <span class="ruby-value">5</span>]
<span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice_when</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span>, <span class="ruby-identifier">j</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">j</span> }.<span class="ruby-identifier">to_a</span>
<span class="ruby-comment">#=&gt; [[0, 9], [2, 2, 3], [2, 7], [5, 9], [5]]</span>
</pre>

<p>Adjacent evens and odds can be chunked as follows: (Enumerable#chunk is
another way to do it.)</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">7</span>, <span class="ruby-value">5</span>, <span class="ruby-value">9</span>, <span class="ruby-value">2</span>, <span class="ruby-value">0</span>, <span class="ruby-value">7</span>, <span class="ruby-value">9</span>, <span class="ruby-value">4</span>, <span class="ruby-value">2</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice_when</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span>, <span class="ruby-identifier">j</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span>.<span class="ruby-identifier">even?</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">j</span>.<span class="ruby-identifier">even?</span> }.<span class="ruby-identifier">to_a</span>
<span class="ruby-comment">#=&gt; [[7, 5, 9], [2, 0], [7, 9], [4, 2, 0]]</span>
</pre>

<p>Paragraphs (non-empty lines with trailing empty lines) can be chunked as
follows: (See <a href="http://ruby-doc.org/core-2.2.0/Enumerable.html#method-i-chunk">#chunk</a> to ignore
empty lines.)</p>

<pre class="ruby"><span class="ruby-identifier">lines</span> = [<span class="ruby-string">"foo\n"</span>, <span class="ruby-string">"bar\n"</span>, <span class="ruby-string">"\n"</span>, <span class="ruby-string">"baz\n"</span>, <span class="ruby-string">"qux\n"</span>]
<span class="ruby-identifier">p</span> <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">slice_when</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">l1</span>, <span class="ruby-identifier">l2</span><span class="ruby-operator">|</span> <span class="ruby-regexp">/\A\s*\z/</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">l1</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-regexp">/\S/</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">l2</span> }.<span class="ruby-identifier">to_a</span>
<span class="ruby-comment">#=&gt; [["foo\n", "bar\n", "\n"], ["baz\n", "qux\n"]]</span>
</pre>
            

            
            <div class="method-source-code" id="slice_when-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_slice_when(VALUE enumerable)
{
    VALUE enumerator;
    VALUE pred;

    pred = rb_block_proc();

    enumerator = rb_obj_alloc(rb_cEnumerator);
    rb_ivar_set(enumerator, rb_intern("slicewhen_enum"), enumerable);
    rb_ivar_set(enumerator, rb_intern("slicewhen_pred"), pred);

    rb_block_call(enumerator, idInitialize, 0, 0, slicewhen_i, enumerator);
    return enumerator;
}
            </pre> 
            </div><!-- slice_when-source -->
            
          </div>

          

          
        </div><!-- slice_when-method -->
      
        <div id="sort-method" class="method-detail ">
          <a name="method-i-sort"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">sort                  → array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">sort { |a, b| block } → array</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array containing the items in <em>enum</em> sorted, either
according to their own <code>&lt;=&gt;</code> method, or by using the
results of the supplied block. The block should return -1, 0, or +1
depending on the comparison between <em>a</em> and <em>b</em>. As of Ruby
1.8, the method <code>Enumerable#sort_by</code> implements a built-in
Schwartzian Transform, useful when key computation or comparison is
expensive.</p>

<pre class="ruby"><span class="ruby-node">%w(rhea kea flea)</span>.<span class="ruby-identifier">sort</span>          <span class="ruby-comment">#=&gt; ["flea", "kea", "rhea"]</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">sort</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">b</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">a</span> }  <span class="ruby-comment">#=&gt; [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]</span>
</pre>
            

            
            <div class="method-source-code" id="sort-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_sort(VALUE obj)
{
    return rb_ary_sort(enum_to_a(0, 0, obj));
}
            </pre> 
            </div><!-- sort-source -->
            
          </div>

          

          
        </div><!-- sort-method -->
      
        <div id="sort_by-method" class="method-detail ">
          <a name="method-i-sort_by"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">sort_by { |obj| block }   → array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">sort_by                   → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Sorts <em>enum</em> using a set of keys generated by mapping the values in
<em>enum</em> through the given block.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-node">%w{apple pear fig}</span>.<span class="ruby-identifier">sort_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span>}
              <span class="ruby-comment">#=&gt; ["fig", "pear", "apple"]</span>
</pre>

<p>The current implementation of <code>sort_by</code> generates an array of
tuples containing the original collection element and the mapped value.
This makes <code>sort_by</code> fairly expensive when the keysets are
simple.</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">'benchmark'</span>

<span class="ruby-identifier">a</span> = (<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100000</span>).<span class="ruby-identifier">map</span> { <span class="ruby-identifier">rand</span>(<span class="ruby-value">100000</span>) }

<span class="ruby-constant">Benchmark</span>.<span class="ruby-identifier">bm</span>(<span class="ruby-value">10</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">b</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">b</span>.<span class="ruby-identifier">report</span>(<span class="ruby-string">"Sort"</span>)    { <span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort</span> }
  <span class="ruby-identifier">b</span>.<span class="ruby-identifier">report</span>(<span class="ruby-string">"Sort by"</span>) { <span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> } }
<span class="ruby-keyword">end</span>
</pre>

<p><em>produces:</em></p>

<pre>user     system      total        real
Sort        0.180000   0.000000   0.180000 (  0.175469)
Sort by     1.980000   0.040000   2.020000 (  2.013586)</pre>

<p>However, consider the case where comparing the keys is a non-trivial
operation. The following code sorts some files on modification time using
the basic <code>sort</code> method.</p>

<pre class="ruby"><span class="ruby-identifier">files</span> = <span class="ruby-constant">Dir</span>[<span class="ruby-string">"*"</span>]
<span class="ruby-identifier">sorted</span> = <span class="ruby-identifier">files</span>.<span class="ruby-identifier">sort</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">a</span>).<span class="ruby-identifier">mtime</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">b</span>).<span class="ruby-identifier">mtime</span> }
<span class="ruby-identifier">sorted</span>   <span class="ruby-comment">#=&gt; ["mon", "tues", "wed", "thurs"]</span>
</pre>

<p>This sort is inefficient: it generates two new <code>File</code> objects
during every comparison. A slightly better technique is to use the
<code>Kernel#test</code> method to generate the modification times
directly.</p>

<pre class="ruby"><span class="ruby-identifier">files</span> = <span class="ruby-constant">Dir</span>[<span class="ruby-string">"*"</span>]
<span class="ruby-identifier">sorted</span> = <span class="ruby-identifier">files</span>.<span class="ruby-identifier">sort</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">test</span>(<span class="ruby-value">?M</span>, <span class="ruby-identifier">a</span>) <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">test</span>(<span class="ruby-value">?M</span>, <span class="ruby-identifier">b</span>)
}
<span class="ruby-identifier">sorted</span>   <span class="ruby-comment">#=&gt; ["mon", "tues", "wed", "thurs"]</span>
</pre>

<p>This still generates many unnecessary <code>Time</code> objects. A more
efficient technique is to cache the sort keys (modification times in this
case) before the sort. Perl users often call this approach a Schwartzian
Transform, after Randal Schwartz. We construct a temporary array, where
each element is an array containing our sort key along with the filename.
We sort this array, and then extract the filename from the result.</p>

<pre class="ruby"><span class="ruby-identifier">sorted</span> = <span class="ruby-constant">Dir</span>[<span class="ruby-string">"*"</span>].<span class="ruby-identifier">collect</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
   [<span class="ruby-identifier">test</span>(<span class="ruby-value">?M</span>, <span class="ruby-identifier">f</span>), <span class="ruby-identifier">f</span>]
}.<span class="ruby-identifier">sort</span>.<span class="ruby-identifier">collect</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span> <span class="ruby-identifier">f</span>[<span class="ruby-value">1</span>] }
<span class="ruby-identifier">sorted</span>   <span class="ruby-comment">#=&gt; ["mon", "tues", "wed", "thurs"]</span>
</pre>

<p>This is exactly what <code>sort_by</code> does internally.</p>

<pre class="ruby"><span class="ruby-identifier">sorted</span> = <span class="ruby-constant">Dir</span>[<span class="ruby-string">"*"</span>].<span class="ruby-identifier">sort_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span> <span class="ruby-identifier">test</span>(<span class="ruby-value">?M</span>, <span class="ruby-identifier">f</span>) }
<span class="ruby-identifier">sorted</span>   <span class="ruby-comment">#=&gt; ["mon", "tues", "wed", "thurs"]</span>
</pre>
            

            
            <div class="method-source-code" id="sort_by-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_sort_by(VALUE obj)
{
    VALUE ary, buf;
    NODE *memo;
    long i;
    struct sort_by_data *data;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    if (RB_TYPE_P(obj, T_ARRAY) &amp;&amp; RARRAY_LEN(obj) &lt;= LONG_MAX/2) {
        ary = rb_ary_new2(RARRAY_LEN(obj)*2);
    }
    else {
        ary = rb_ary_new();
    }
    RBASIC_CLEAR_CLASS(ary);
    buf = rb_ary_tmp_new(SORT_BY_BUFSIZE*2);
    rb_ary_store(buf, SORT_BY_BUFSIZE*2-1, Qnil);
    memo = NEW_MEMO(0, 0, 0);
    OBJ_INFECT(memo, obj);
    data = (struct sort_by_data *)&amp;memo-&gt;u1;
    data-&gt;ary = ary;
    data-&gt;buf = buf;
    data-&gt;n = 0;
    rb_block_call(obj, id_each, 0, 0, sort_by_i, (VALUE)memo);
    ary = data-&gt;ary;
    buf = data-&gt;buf;
    if (data-&gt;n) {
        rb_ary_resize(buf, data-&gt;n*2);
        rb_ary_concat(ary, buf);
    }
    if (RARRAY_LEN(ary) &gt; 2) {
        RARRAY_PTR_USE(ary, ptr,
                      ruby_qsort(ptr, RARRAY_LEN(ary)/2, 2*sizeof(VALUE),
                                 sort_by_cmp, (void *)ary));
    }
    if (RBASIC(ary)-&gt;klass) {
        rb_raise(rb_eRuntimeError, "sort_by reentered");
    }
    for (i=1; i&lt;RARRAY_LEN(ary); i+=2) {
        RARRAY_ASET(ary, i/2, RARRAY_AREF(ary, i));
    }
    rb_ary_resize(ary, RARRAY_LEN(ary)/2);
    RBASIC_SET_CLASS_RAW(ary, rb_cArray);
    OBJ_INFECT(ary, memo);

    return ary;
}
            </pre> 
            </div><!-- sort_by-source -->
            
          </div>

          

          
        </div><!-- sort_by-method -->
      
        <div id="take-method" class="method-detail ">
          <a name="method-i-take"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">take(n)               → array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns first n elements from <em>enum</em>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take</span>(<span class="ruby-value">3</span>)             <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take</span>(<span class="ruby-value">30</span>)            <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5, 0]</span>
</pre>
            

            
            <div class="method-source-code" id="take-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_take(VALUE obj, VALUE n)
{
    NODE *memo;
    VALUE result;
    long len = NUM2LONG(n);

    if (len &lt; 0) {
        rb_raise(rb_eArgError, "attempt to take negative size");
    }

    if (len == 0) return rb_ary_new2(0);
    result = rb_ary_new2(len);
    memo = NEW_MEMO(result, 0, len);
    rb_block_call(obj, id_each, 0, 0, take_i, (VALUE)memo);
    return result;
}
            </pre> 
            </div><!-- take-source -->
            
          </div>

          

          
        </div><!-- take-method -->
      
        <div id="take_while-method" class="method-detail ">
          <a name="method-i-take_while"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">take_while { |arr| block } → array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">take_while                 → an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Passes elements to the block until the block returns <code>nil</code> or
<code>false</code>, then stops iterating and returns an array of all prior
elements.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take_while</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span> }   <span class="ruby-comment">#=&gt; [1, 2]</span>
</pre>
            

            
            <div class="method-source-code" id="take_while-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_take_while(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);
    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, take_while_i, ary);
    return ary;
}
            </pre> 
            </div><!-- take_while-source -->
            
          </div>

          

          
        </div><!-- take_while-method -->
      
        <div id="to_a-method" class="method-detail ">
          <a name="method-i-to_a"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_a(*args)      → array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array containing the items in <em>enum</em>.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">7</span>).<span class="ruby-identifier">to_a</span>                       <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5, 6, 7]</span>
{ <span class="ruby-string">'a'</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>, <span class="ruby-string">'b'</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>, <span class="ruby-string">'c'</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">3</span> }.<span class="ruby-identifier">to_a</span>   <span class="ruby-comment">#=&gt; [["a", 1], ["b", 2], ["c", 3]]</span>

<span class="ruby-identifier">require</span> <span class="ruby-string">'prime'</span>
<span class="ruby-constant">Prime</span>.<span class="ruby-identifier">entries</span> <span class="ruby-value">10</span>                  <span class="ruby-comment">#=&gt; [2, 3, 5, 7]</span>
</pre>
            

            
            <div class="method-source-code" id="to_a-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_to_a(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary = rb_ary_new();

    rb_block_call(obj, id_each, argc, argv, collect_all, ary);
    OBJ_INFECT(ary, obj);

    return ary;
}
            </pre> 
            </div><!-- to_a-source -->
            
          </div>

          

          
        </div><!-- to_a-method -->
      
        <div id="to_h-method" class="method-detail ">
          <a name="method-i-to_h"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_h(*args)  → hash</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the result of interpreting <em>enum</em> as a list of <code>[key,
value]</code> pairs.</p>

<pre>%i[hello world].each_with_index.to_h
  # =&gt; {:hello =&gt; 0, :world =&gt; 1}</pre>
            

            
            <div class="method-source-code" id="to_h-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_to_h(int argc, VALUE *argv, VALUE obj)
{
    VALUE hash = rb_hash_new();
    rb_block_call(obj, id_each, argc, argv, enum_to_h_i, hash);
    OBJ_INFECT(hash, obj);
    return hash;
}
            </pre> 
            </div><!-- to_h-source -->
            
          </div>

          

          
        </div><!-- to_h-method -->
      
        <div id="zip-method" class="method-detail ">
          <a name="method-i-zip"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">zip(arg, ...)                  → an_array_of_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">zip(arg, ...) { |arr| block }  → nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Takes one element from <em>enum</em> and merges corresponding elements from
each <em>args</em>.  This generates a sequence of <em>n</em>-element
arrays, where <em>n</em> is one more than the count of arguments.  The
length of the resulting sequence will be <code>enum#size</code>.  If the
size of any argument is less than <code>enum#size</code>, <code>nil</code>
values are supplied. If a block is given, it is invoked for each output
array, otherwise an array of arrays is returned.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span> ]
<span class="ruby-identifier">b</span> = [ <span class="ruby-value">7</span>, <span class="ruby-value">8</span>, <span class="ruby-value">9</span> ]

<span class="ruby-identifier">a</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">b</span>)                 <span class="ruby-comment">#=&gt; [[4, 7], [5, 8], [6, 9]]</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>)      <span class="ruby-comment">#=&gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>)         <span class="ruby-comment">#=&gt; [[1, 4, 7], [2, 5, 8]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">zip</span>([<span class="ruby-value">1</span>, <span class="ruby-value">2</span>], [<span class="ruby-value">8</span>])       <span class="ruby-comment">#=&gt; [[4, 1, 8], [5, 2, nil], [6, nil, nil]]</span>
</pre>
            

            
            <div class="method-source-code" id="zip-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
enum_zip(int argc, VALUE *argv, VALUE obj)
{
    int i;
    ID conv;
    NODE *memo;
    VALUE result = Qnil;
    VALUE args = rb_ary_new4(argc, argv);
    int allary = TRUE;

    argv = RARRAY_PTR(args);
    for (i=0; i&lt;argc; i++) {
        VALUE ary = rb_check_array_type(argv[i]);
        if (NIL_P(ary)) {
            allary = FALSE;
            break;
        }
        argv[i] = ary;
    }
    if (!allary) {
        CONST_ID(conv, "to_enum");
        for (i=0; i&lt;argc; i++) {
            if (!rb_respond_to(argv[i], id_each)) {
                rb_raise(rb_eTypeError, "wrong argument type %s (must respond to :each)",
                    rb_obj_classname(argv[i]));
            }
            argv[i] = rb_funcall(argv[i], conv, 1, ID2SYM(id_each));
        }
    }
    if (!rb_block_given_p()) {
        result = rb_ary_new();
    }
    /* use NODE_DOT2 as memo(v, v, -) */
    memo = rb_node_newnode(NODE_DOT2, result, args, 0);
    rb_block_call(obj, id_each, 0, 0, allary ? zip_ary : zip_i, (VALUE)memo);

    return result;
}
            </pre> 
            </div><!-- zip-source -->
            
          </div>

          

          
        </div><!-- zip-method -->
      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  
  <div id="tx_Enumerable_versioned" class="associated_wrapper"><!-- void  -->
</div><script type="text/javascript">$("#tx_Enumerable_versioned").load("/associated/2.2.0/Enumerable.ihtml");</script> <div id="tx_Enumerable" class="associated_wrapper"><!-- void  -->
</div><script type="text/javascript">$("#tx_Enumerable").load("/associated/Enumerable.ihtml");</script> 
      
  <!-- disqus ? -->
   <div class="info">
  <p>Commenting is here to help enhance the documentation.  For example, code samples, or clarification of the documentation.</p>
  <p>If you have questions about Ruby or the documentation, please post to one of the <a href="http://www.ruby-lang.org/en/community/mailing-lists/">Ruby mailing lists</a>.  You will get better, faster, help that way.</p>
  <p>If you wish to post a correction of the docs, please do so, but also <a href="http://bugs.ruby-lang.org/">file bug report</a> so that it can be corrected for the next release. Thank you.</p>
  <p>If you want to help improve the Ruby documentation, please visit <a href="http://documenting-ruby.org/">Documenting-ruby.org</a>.</p> 
    </div>


  
  </div><!-- documentation -->
  <div id="dynamic">
  </div>
      
      <div id="disqus_thread"><iframe verticalscrolling="no" horizontalscrolling="no" src="arreglo_doc_files/a.html" style="width: 1px ! important; min-width: 100% ! important; border: medium none ! important; overflow: hidden ! important; height: 408px ! important;" title="Disqus" tabindex="0" scrolling="no" allowtransparency="true" name="dsq-app2" id="dsq-app2" frameborder="0" width="100%"></iframe></div>
<script>
/**
* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');

s.src = '//ruby-doc.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

      
<div class="grids wrapper" id="footer">
  <p><small>This page was generated for Ruby 2.2.0</small></p> 
  
   <p><a href="http://ruby-doc.org/">Ruby-doc.org</a> is provided by <a href="http://jamesbritt.com/">James Britt</a> and <a href="http://neurogami.com/">Neurogami</a>. <a href="http://neurogami.com/">Maximum R+D</a>.  </p><div class="oio-inline"><ins style="text-decoration: none;"><a href="http://ras.ruby-doc.org/vvv/delivery/cjgbk.php?oaparams=2__bannerid=1__zoneid=1__source=%7Bobfs%3A%7D__cb=b350f3ebdf__oadest=http%3A%2F%2Fmusic.neurogami.com%2Falbum%2Fmaximum-r-d" target="top">Since you're reading the fine print, check out MaximumR&amp;D, the new album from  Neurogami</a><div id="beacon_b350f3ebdf" style="position: absolute; left: 0px; top: 0px; visibility: hidden;"><img src="arreglo_doc_files/ljgbg.gif" alt="" style="width: 0px; height: 0px;" height="0" width="0"></div></ins><script async="" src="arreglo_doc_files/thesinkjs.php"></script></div><p></p>
 
       <p><small>Generated with Ruby-doc Rdoc Generator 0.35.3</small>.</p>
  </div>
</div>
  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-335317-2', 'auto');
  ga('send', 'pageview');

</script>


    
 <script type="text/javascript">
$(document).ready(function() {
      $.ajaxSetup({ cache: false });
      $("#vulns-alert").load("/associated/vulns.html");
    });

    </script>


 
		<script type="text/javascript">

	function loadPlus(plusdocs){
			$(plusdocs).find("div[class='associated_wrapper']").each (function() {
					$("#" + this.id).append($(plusdocs).find("#" + this.id ));
					});
	} 

   //function loadInline(json){
   // for (var lookFor in json) {
    //  $(lookFor).after(json[lookFor]);
    // }
  // } // end loadInline


$(document).ready(function() {
		$.ajaxSetup({ cache: false });
			$.get('/associated/2.2.0/plus_Enumerable.ihtml', 
			function(plusdocs) {
			setTimeout(function() {
				loadPlus(plusdocs);
				}, 2000);
			}
			);


//     $.ajax({
//     dataType: "json",
//      url: '/associated/2.2.0/inline_Enumerable.js',
//      success: function(json) {
// 			setTimeout(function() {
// 				loadInline(json);
// 				}, 2000);
// 			}
//    });

		});
</script>
		




</body></html>